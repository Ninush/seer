return(RWDaccuracy)
}, error=function(e){return(NA)})
}
#' Calculate accuracy measure based on white noise process
#' @param ts_info list containing training and test part of a time series
#' @param function_name function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @return returns accuracy measure calculated based on white noise process
#' @export
accuracy_wn <- function(ts_info, function_name){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
tryCatch({
fit_WN <- forecast::auto.arima(training, d=0, D=0, max.p=0, max.q = 0,
max.Q=0, max.P = 0)
forecastWN <- forecast(fit_WN,h)$mean
ACCURACY <- match.fun(function_name)
WNaccuracy <- ACCURACY(forecast=forecastWN,test=test, training=training)
return(WNaccuracy)
}, error=function(e){return(NULL)})
}
#' Calculate accuracy measure based on Theta method
#' @param ts_info list containing training and test part of a time series
#' @param function_name function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @return returns accuracy measure calculated based on theta method
#' @export
accuracy_theta <- function(ts_info, function_name){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
m <- frequency(training)
ACCURACY <- match.fun(function_name)
tryCatch({
if (m > 1){
# using stheta method with seasonal adjustment
# require(forecTheta)
forecastTheta <- forecTheta::stheta(training,h=h, s='additive')$mean
THETAaccuracy <- ACCURACY(forecast=forecastTheta, test=test, training=training)
} else {
# using thetaf method
forecastTheta <-forecast::thetaf(training,h=length(test))$mean
THETAaccuracy <- ACCURACY(forecast=forecastTheta, test=test, training=training)
}
return(THETAaccuracy)
}, error=function(e){return(NULL)})
}
#' Calculate accuracy measure based on STL-AR method
#' @param ts_info list containing training and test part of a time series
#' @param function_name function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @return accuracy measure calculated based on stlar method
#' @export
accuracy_stlar <- function(ts_info, function_name){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
forecastSTLAR <- stlar(training,h=h)$mean
ACCURACY <- match.fun(function_name)
tryCatch({
STLARaccuracy <- ACCURACY(forecast=forecastSTLAR, test=test, training=training)
return(STLARaccuracy)
}, error=function(e){return(NULL)})
}
#' Calculate accuracy measure calculated based on neural network forecasts
#' @param ts_info list containing training and test part of a time series
#' @param function_name function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @return accuracy measure calculated based on neural network forecasts
#' @export
accuracy_nn <- function(ts_info, function_name){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
tryCatch({
fit_nnetar <- forecast::nnetar(training)
forecastnnetar <- forecast(fit_nnetar, h=h)$mean
ACCURACY <- match.fun(function_name)
nnetarACCURACY <- ACCURACY(forecast=forecastnnetar, test=test, training=training)
return(nnetarACCURACY)
}, error=function(e){return(NULL)})
}
#' Calculate accuracy measure based on snaive method
#' @param ts_info list containing training and test part of a time series
#' @param function_name function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @return accuracy measure calculated based on snaive method
#' @export
accuracy_snaive <- function(ts_info, function_name){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
tryCatch({
forecastSNAIVE <- forecast::snaive(training, h=length(test))$mean
ACCURACY <- match.fun(function_name)
SNAIVEaccuracy <- ACCURACY(forecast=forecastSNAIVE, test=test, training=training)
return(SNAIVEaccuracy)
}, error=function(e){return(NULL)})
}
#' Calculate accuracy based on MSTL
#' @param ts_info list containing training and test part of a time series
#' @param function_name function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @return accuracy measure calculated based on multiple seasonal decomposition
#' @export
accuracy_mstl <- function(ts_info, function_name){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
tryCatch({
fit_mstl <- forecast::mstl(training)
forecastMSTL <- forecast(training, h=length(test))$mean
ACCURACY <- match.fun(function_name)
MSTLaccuracy <- ACCURACY(forecast=forecastMSTL, test=test, training=training)
return(MSTLaccuracy)
}, error=function(e){return(NULL)})
}
#' Calculate accuracy measure based on TBATS
#' @param ts_info list containing training and test part of a time series
#' @param function_name function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @return accuracy measure calculated based on TBATS models
#' @export
accuracy_tbats <- function(ts_info, function_name){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
ACCURACY <- match.fun(function_name)
tryCatch({
fitTBAT <- forecast::tbats(training)
forecastTBATS <- forecast(fitTBAT, h=h)$mean
TBATSaccuracy <- ACCURACY(forecast=forecastTBATS, test=test, training=training)
return(TBATSaccuracy)
}, error=function(e){return(NULL)})
}
fcast_accuracy(tslist=tslist,models= c("arima","ets","rw","rwd", "theta", "stlar", "nn", "snaive", "mstl"),database ="M3", cal_avg, h=6)
tslist <- list(M3[[1]], M3[[2]])
models= c("arima","ets","rw","rwd", "theta", "stlar", "nn", "snaive", "mstl")
arima_models <- NA
ets_models <- NA
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
database="M3"
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
if ("arima"%in% models) {
arima_cal <- lapply(train_test, accuracy_arima, function_name=accuracyFun)
arima_models <- sapply(arima_cal, function(temp){temp$ARIMAmodel})
}
accuracyFun <- cal_avg()
accuracyFun <- cal_avg
cal_avg
#'@param forecast forecast obtained from a fitted to the training period
#'@return returns a single value: mean on MASE and sMAPE
#'@author Thiyanga Talagala
#'@export
#'@examples
#'require(Mcomp)
#'require(magrittr)
#'ts <- M3[[1]]$x
#'fcast_arima <- auto.arima(ts) %>% forecast(h=6)
#'cal_avg(M3[[1]]$x, M3[[1]]$xx, fcast_arima$mean)
cal_avg <- function(training, test, forecast){
method_MASE <- cal_MASE(training, test, forecast)
method_sMAPE <- cal_sMAPE(training, test, forecast)
avg <- c(method_MASE, method_sMAPE)
return(avg)
}
accuracyFun <- cal_avg
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
if ("arima"%in% models) {
arima_cal <- lapply(train_test, accuracy_arima, function_name=accuracyFun)
arima_models <- sapply(arima_cal, function(temp){temp$ARIMAmodel})
}
if ("ets"%in% models) {
ets_cal <- lapply(train_test, accuracy_ets, function_name=accuracyFun)
ets_models <- sapply(ets_cal, function(temp){temp$ETSmodel})
}
mat <- sapply(models, function(f){
switch(f,
arima = sapply(arima_cal, function(temp){temp$ARIMAaccuracy}),
ets = sapply(ets_cal, function(temp){temp$ETSaccuracy}),
rw = sapply(train_test, accuracy_rw, function_name=accuracyFun),
rwd = sapply(train_test, accuracy_rwd, function_name=accuracyFun),
wn = sapply(train_test, accuracy_wn, function_name=accuracyFun),
theta = sapply(train_test, accuracy_theta, function_name=accuracyFun),
stlar = sapply(train_test, accuracy_stlar, function_name=accuracyFun),
nn = sapply(train_test, accuracy_nn, function_name=accuracyFun),
snaive = sapply(train_test, accuracy_snaive, function_name=accuracyFun),
mstl = sapply(train_test, accuracy_mstl, function_name=accuracyFun),
tbats = sapply(train_test, accuracy_tbats, function_name=accuracyFun)
)
})
#' forecast seasonally adjusted data, while the seasonal naive method is used to forecast
#' the seasonal component
#' @param y a univariate time series
#' @param h forecast horizon
#' @param s.window Either the character string “periodic” or the span (in lags) of the loess window for seasonal extraction
#' @param robust logical indicating if robust fitting be used in the loess procedue
#' @return return object of class forecast
#' @author Thiyanga Talagala
#' @import forecast
#' @export
stlar <- function(y, h=10, s.window=11, robust=FALSE)
{
if(!is.ts(y))
y <- ts(y, frequency=findfrequency(y))
if(frequency(y)==1 | length(y) <= 2*frequency(y))
return(forecast(auto.arima(y, max.q=0), h=h))
fit_stlm <- stlm(y,s.window=s.window, robust=robust, modelfunction=ar)
fcast <- forecast(fit_stlm, h=h)
return(fcast)
}
mat <- sapply(models, function(f){
switch(f,
arima = sapply(arima_cal, function(temp){temp$ARIMAaccuracy}),
ets = sapply(ets_cal, function(temp){temp$ETSaccuracy}),
rw = sapply(train_test, accuracy_rw, function_name=accuracyFun),
rwd = sapply(train_test, accuracy_rwd, function_name=accuracyFun),
wn = sapply(train_test, accuracy_wn, function_name=accuracyFun),
theta = sapply(train_test, accuracy_theta, function_name=accuracyFun),
stlar = sapply(train_test, accuracy_stlar, function_name=accuracyFun),
nn = sapply(train_test, accuracy_nn, function_name=accuracyFun),
snaive = sapply(train_test, accuracy_snaive, function_name=accuracyFun),
mstl = sapply(train_test, accuracy_mstl, function_name=accuracyFun),
tbats = sapply(train_test, accuracy_tbats, function_name=accuracyFun)
)
})
return(list(accuracy=mat, ARIMA = arima_models, ETS =ets_models))
list(accuracy=mat, ARIMA = arima_models, ETS =ets_models)
#'@param forecast forecast obtained from a fitted to the training period
#'@return returns a single value: mean on MASE and sMAPE
#'@author Thiyanga Talagala
#'@export
#'@examples
#'require(Mcomp)
#'require(magrittr)
#'ts <- M3[[1]]$x
#'fcast_arima <- auto.arima(ts) %>% forecast(h=6)
#'cal_avg(M3[[1]]$x, M3[[1]]$xx, fcast_arima$mean)
cal_avg <- function(training, test, forecast){
method_MASE <- cal_MASE(training, test, forecast)
method_sMAPE <- cal_sMAPE(training, test, forecast)
avg <- c(method_MASE, method_sMAPE)
return(avg)
}
require(Mcomp)
require(magrittr)
ts <- M3[[1]]$x
fcast_arima <- auto.arima(ts) %>% forecast(h=6)
cal_avg(M3[[1]]$x, M3[[1]]$xx, fcast_arima$mean)
sapply(train_test, accuracy_rw, function_name=accuracyFun)
library(seer)
sapply(train_test, accuracy_rw, function_name=accuracyFun)
mat <- sapply(models, function(f){
switch(f,
arima = sapply(arima_cal, function(temp){temp$ARIMAaccuracy}),
ets = sapply(ets_cal, function(temp){temp$ETSaccuracy}),
rw = sapply(train_test, accuracy_rw, function_name=accuracyFun),
rwd = sapply(train_test, accuracy_rwd, function_name=accuracyFun),
wn = sapply(train_test, accuracy_wn, function_name=accuracyFun),
theta = sapply(train_test, accuracy_theta, function_name=accuracyFun),
stlar = sapply(train_test, accuracy_stlar, function_name=accuracyFun),
nn = sapply(train_test, accuracy_nn, function_name=accuracyFun),
snaive = sapply(train_test, accuracy_snaive, function_name=accuracyFun),
mstl = sapply(train_test, accuracy_mstl, function_name=accuracyFun),
tbats = sapply(train_test, accuracy_tbats, function_name=accuracyFun)
)
})
matrix(data, nrow = rows, ncol = cols)
mat
arima_models <- NA
ets_models <- NA
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
if ("arima"%in% models) {
arima_cal <- lapply(train_test, accuracy_arima, function_name=accuracyFun)
arima_models <- sapply(arima_cal, function(temp){temp$ARIMAmodel})
}
if ("ets"%in% models) {
ets_cal <- lapply(train_test, accuracy_ets, function_name=accuracyFun)
ets_models <- sapply(ets_cal, function(temp){temp$ETSmodel})
}
mat <- sapply(models, function(f){
switch(f,
arima = sapply(arima_cal, function(temp){temp$ARIMAaccuracy}),
ets = sapply(ets_cal, function(temp){temp$ETSaccuracy}),
rw = sapply(train_test, accuracy_rw, function_name=accuracyFun),
rwd = sapply(train_test, accuracy_rwd, function_name=accuracyFun),
wn = sapply(train_test, accuracy_wn, function_name=accuracyFun),
theta = sapply(train_test, accuracy_theta, function_name=accuracyFun),
stlar = sapply(train_test, accuracy_stlar, function_name=accuracyFun),
nn = sapply(train_test, accuracy_nn, function_name=accuracyFun),
snaive = sapply(train_test, accuracy_snaive, function_name=accuracyFun),
mstl = sapply(train_test, accuracy_mstl, function_name=accuracyFun),
tbats = sapply(train_test, accuracy_tbats, function_name=accuracyFun)
)
})
list(accuracy=mat, ARIMA = arima_models, ETS =ets_models)
accuracyFun <- cal_MASE
arima_models <- NA
ets_models <- NA
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
if ("arima"%in% models) {
arima_cal <- lapply(train_test, accuracy_arima, function_name=accuracyFun)
arima_models <- sapply(arima_cal, function(temp){temp$ARIMAmodel})
}
if ("ets"%in% models) {
ets_cal <- lapply(train_test, accuracy_ets, function_name=accuracyFun)
ets_models <- sapply(ets_cal, function(temp){temp$ETSmodel})
}
mat <- sapply(models, function(f){
switch(f,
arima = sapply(arima_cal, function(temp){temp$ARIMAaccuracy}),
ets = sapply(ets_cal, function(temp){temp$ETSaccuracy}),
rw = sapply(train_test, accuracy_rw, function_name=accuracyFun),
rwd = sapply(train_test, accuracy_rwd, function_name=accuracyFun),
wn = sapply(train_test, accuracy_wn, function_name=accuracyFun),
theta = sapply(train_test, accuracy_theta, function_name=accuracyFun),
stlar = sapply(train_test, accuracy_stlar, function_name=accuracyFun),
nn = sapply(train_test, accuracy_nn, function_name=accuracyFun),
snaive = sapply(train_test, accuracy_snaive, function_name=accuracyFun),
mstl = sapply(train_test, accuracy_mstl, function_name=accuracyFun),
tbats = sapply(train_test, accuracy_tbats, function_name=accuracyFun)
)
})
list(accuracy=mat, ARIMA = arima_models, ETS =ets_models)
cal_measures
cal_avg
#'@param forecast forecast obtained from a fitted to the training period
#'@return returns a single value: mean on MASE and sMAPE
#'@author Thiyanga Talagala
#'@export
#'@examples
#'require(Mcomp)
#'require(magrittr)
#'ts <- M3[[1]]$x
#'fcast_arima <- auto.arima(ts) %>% forecast(h=6)
#'cal_m4measures(M3[[1]]$x, M3[[1]]$xx, fcast_arima$mean)
cal_m4measures <- function(training, test, forecast){
method_MASE <- cal_MASE(training, test, forecast)
method_sMAPE <- cal_sMAPE(training, test, forecast)
measures <- c(MASE=method_MASE, sMAPE=method_sMAPE)
return(measures)
}
require(Mcomp)
require(magrittr)
ts <- M3[[1]]$x
fcast_arima <- auto.arima(ts) %>% forecast(h=6)
cal_m4measures(M3[[1]]$x, M3[[1]]$xx, fcast_arima$mean)
accuracyFun <- cal_m4measures
arima_models <- NA
ets_models <- NA
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
if ("arima"%in% models) {
arima_cal <- lapply(train_test, accuracy_arima, function_name=accuracyFun)
arima_models <- sapply(arima_cal, function(temp){temp$ARIMAmodel})
}
if ("ets"%in% models) {
ets_cal <- lapply(train_test, accuracy_ets, function_name=accuracyFun)
ets_models <- sapply(ets_cal, function(temp){temp$ETSmodel})
}
mat <- sapply(models, function(f){
switch(f,
arima = sapply(arima_cal, function(temp){temp$ARIMAaccuracy}),
ets = sapply(ets_cal, function(temp){temp$ETSaccuracy}),
rw = sapply(train_test, accuracy_rw, function_name=accuracyFun),
rwd = sapply(train_test, accuracy_rwd, function_name=accuracyFun),
wn = sapply(train_test, accuracy_wn, function_name=accuracyFun),
theta = sapply(train_test, accuracy_theta, function_name=accuracyFun),
stlar = sapply(train_test, accuracy_stlar, function_name=accuracyFun),
nn = sapply(train_test, accuracy_nn, function_name=accuracyFun),
snaive = sapply(train_test, accuracy_snaive, function_name=accuracyFun),
mstl = sapply(train_test, accuracy_mstl, function_name=accuracyFun),
tbats = sapply(train_test, accuracy_tbats, function_name=accuracyFun)
)
})
list(accuracy=mat, ARIMA = arima_models, ETS =ets_models)
library(seer)
library(seer)
library(seer)
#' @param tslist a list of univariate time series
#' @param seasonal if FALSE, restricts to features suitable for non-seasonal data
#' @param m frequency of the time series
#' @param lagmax maximum lag at which to calculate the acf (quarterly series-5L and monthly-13L)
#' @param database whether the time series is from mcomp or other
#' @param h forecast horizon
#' @return dataframe: each column represent a feature and each row represent a time series
#' @importFrom magrittr %>%
#' @author Thiyanga Talagala
#' @export
cal_features <- function(tslist, seasonal=FALSE, m=1, lagmax=2L, database, h){ # tslist = yearly_m1,
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
train <- lapply(train_test, function(temp){temp$training})
ts_features_pkg <- tsfeatures::tsfeatures(train, c("entropy",
"lumpiness",
"stability",
"hurst",
"stl_features",
"acf_features",
"pacf_features",
"nonlinearity"))
if (seasonal==FALSE){
ts_features1 <- ts_features_pkg %>% dplyr::select ("entropy", "lumpiness", "stability", "hurst",
"trend", "spike", "linearity", "curvature",
"e_acf1", "x_acf1", "diff1_acf1", "diff2_acf1",
"x_pacf5","diff1x_pacf5", "diff2x_pacf5", "nonlinearity")
seer_features_nonseasonal <- lapply(train, function(temp1){c(
seer::e_acf1(temp1),
seer::unitroot(temp1))})
seer_features_nonseasonal_DF <- as.data.frame(do.call("rbind", seer_features_nonseasonal))
ts_features <- dplyr::bind_cols(ts_features1, seer_features_nonseasonal_DF)
} else {
ts_features1 <- ts_features_pkg %>% dplyr::select ("entropy", "lumpiness", "stability", "hurst",
"trend", "spike", "linearity", "curvature",
"e_acf1", "x_acf1", "diff1_acf1", "diff2_acf1",
"x_pacf5","diff1x_pacf5", "diff2x_pacf5","nonlinearity", "seasonal_strength",
"seas_pacf")
seer_features_seasonal <- lapply(train, function(temp1){c(seer::holtWinter_parameters(temp1),
acf_seasonalDiff(temp1, m, lagmax))})
seer_features_seasonal_DF <- as.data.frame(do.call("rbind", seer_features_seasonal))
ts_features <- dplyr::bind_cols(ts_features1, seer_features_seasonal_DF)
}
ts_featuresDF <- as.data.frame(ts_features)
ts_featuresDF <- dplyr::rename(ts_featuresDF, "spikiness" = "spike")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "y_acf1" = "x_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff1y_acf1" = "diff1_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff2y_acf1" = "diff2_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "y_pacf5" = "x_pacf5")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff1y_pacf5" = "diff1x_pacf5")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff2y_pacf5" = "diff2x_pacf5")
if(seasonal==TRUE){
ts_featuresDF <- dplyr::rename(ts_featuresDF, "seasonality" = "seasonal_strength")
}
length <- lapply(train, function(temp){length(temp)})
length <- unlist(length)
ts_featuresDF$N <- length
seer_features <- lapply(train, function(temp1){c(seer::acf5(temp1), seer::holt_parameters(temp1))})
seer_feature_DF <- as.data.frame(do.call("rbind", seer_features))
featureDF <- dplyr::bind_cols(ts_featuresDF,seer_feature_DF)
return(featureDF)
}
#'@examples
require(Mcomp)
data(M3)
yearly_m3 <- subset(M3, "yearly")
cal_features(yearly_m3, database="M3", h=6)
library(tsfeatures)
data(M3)
yearly_m3 <- subset(M3, "yearly")
cal_features(yearly_m3, database="M3", h=6)
library(seer)
m3q <- subset(M3, "quarterly")
a <- m3q[[1]]
a
a$x
a$xx
y <- a$xx
sdiff <- diff(y, lag=m, differences=1)
m=4
sdiff <- diff(y, lag=m, differences=1)
sdiff
5809.5-5531.50
5809.05-5531.50
lagmax=5L
stats::acf(sdiff, lag.max = lagmax, plot = FALSE)
sEacfy <- stats::acf(sdiff, lag.max = lagmax, plot = FALSE)
sEacfy$acf[2L]
sEacfy$acf[m+1L]
sum((sEacfy$acf[2L:6L])^2)
y <- a$x
sdiff <- diff(y, lag=m, differences=1)
sdiff
sEacfy <- stats::acf(sdiff, lag.max = lagmax, plot = FALSE)
sEacfy
SEacf_1 <- sEacfy$acf[2L]
SEacf_1
SEseas_acf1 <- sEacfy$acf[m+1L]
SEseas_acf1
sEacfy$acf[2L:6L]
sEacfy$acf[2L:10L]
?sum
(sEacfy$acf[2L:10L]^2, na.rm=T)
((sEacfy$acf[2L:10L])^2, na.rm=T)
sum((sEacfy$acf[2L:10L])^2, na.rm=T)
library(seer)
