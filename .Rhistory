fcast$mean
fcast$lower
fcast$upper
training <- a
fit_snaive <- snaive(training, h=h)
h=6
fit_snaive <- snaive(training, h=h)
fit_snaive$mean
fit_snaive$upper
?snaive
stlar(training,h=h,level=c(95))
stlar(training,h=h,level=c(95))
?stlar
?mstl
?forecast
?stlm
?stlf
fcast <- forecast(fit_rw,h, level=c(95))
fit_rw <- rwf(training, drift = FALSE)
fcast <- forecast(fit_rw,h, level=c(95))
fit_rw <- rwf(training, drift = FALSE)
forecast(fit_rw,h
)
fcast <- forecast(fit_rw,h, level=c(95))
h
fit_rw
fcast <- forecast(fit_rw,h
)
fcast
?rwf
install.packages("available")
available::available("seerr", browse = FALSE)
available::available("seer", browse = FALSE)
available::available("forecast", browse = FALSE)
fcast <- rwf(training, drift = FALSE, h=h, level=c(95))
fcast
fcast$lower
fcast <- forecast(auto.arima(training, max.q=0), h=h, level=c(95))
fcast
fit_stlm <- stlm(y,s.window=s.window, robust=robust, modelfunction=ar)
fit_stlm <- stlm(training, s.window=s.window, robust=robust, modelfunction=ar)
training <- M3[[1600]]$xx
training <- M3[[1600]]$x
fit_stlm <- stlm(training, s.window=s.window, robust=robust, modelfunction=ar)
?stlm
fit_stlm <- stlm(training, modelfunction=ar)
fcast <- forecast(fit_stlm, h=h, level=c(95))
fcast
?stm
# using stheta method with seasonal adjustment
# require(forecTheta)
fitTheta <- forecTheta::stm(training,h=h, s='additive', level=c(95))
fitTheta
stm(training,h=h, s='additive', level=c(95))
forecTheta::stheta(training,h=h, s='additive')$mean
forecTheta::stheta(training,h=h)$mean
forecTheta::stm(training,h=h,  s='additive')
forecTheta::stm(training,h=h,  s='additive', level=c(95))
forecTheta::stm(training,h=h,  s='additive', level=95)
forecTheta::stm(training,h=h,  s='additive', level=c(80, 90, 95))
forecTheta::stm(training,h=h,  s='additive', level=c(80, 90, 95))
forecTheta::stheta(training,h=h)$mean
forecTheta::stheta(training,h=h, s='additive')$mean
forecTheta::stheta(training,h=h, s='additive')
forecTheta::stm(training,h=h, s='additive')
forecast::thetaf(training,h=h)
# using thetaf method
fitTheta <-forecast::thetaf(training,h=h, level=c(95))
fitTheta
fit_nnetar <- forecast::nnetar(training)
forecast(fit_nnetar, h=h, level=c(95))
fit_nnetar <- forecast::nnetar(training)
fcast <- forecast(fit_nnetar, PI=TRUE, h=h, level=c(95))
fcast
fit_mstl <- forecast::mstl(training)
forecast_mstl <- forecast(fit_mstl, h=h, level=c(95))
forecast_mstl
?mstl
fit_mstl <- forecast::mstl(training)
forecast_mstl <- forecast(fit_mstl, h=h, level=c(95))
forecast_mstl
?stlf
fit_mstl <- forecast::mstl(training, method=c("arima"))
fit_mstl <- stlm(training)
forecast_mstl <- forecast(fit_mstl, h=h, level=c(95))
accuracy_value[i] <- accuracyFun(forecast=forecast_mstl, training=training, test=test)
forecast_mstl
fit_mstl <- stlm(training, method=c("arima"))
forecast_mstl
fit_mstl <- stlm(training, method="arima")
forecast_mstl <- forecast(fit_mstl, h=h, level=c(95))
forecast_mstl
fit_tbats <- forecast::tbats(training)
forecast_tbats <- forecast(fit_tbats, h=h, level=c(95))
forecast_tbats
fit_wn <- Arima(training,order=c(0,0,0))
forecast_wn <- forecast(fit_wn,h, level=c(95))
forecast_wn
# using stheta method with seasonal adjustment
# require(forecTheta)
fitTheta <- forecTheta::stm(training,h=h,  s='additive', level=c(80, 90, 95))
fitTheta
fitTheta$lower
fitTheta$lower[3]
fitTheta$lower[,3]
fcast <- list(mean=fitTheta$mean, lower = fitTheta$lower[,3], upper = fitTheta$upper[,3])
fcast$mean
fcast$lower
fcast$upper
fit_ets <- ets(training, model= "ZZN", damped = TRUE)
fcast <- forecast(fit_ets,h, level=c(95))
fcast$mean
fit_arima <- auto.arima(training, seasonal = FALSE)
fcast <- forecast(fit_arima,h, level=c(95))
fcast
fit_arma <- auto.arima(training,d=0, stationary=TRUE, seasonal = FALSE)
fcast
fit_sarima <- auto.arima(training, seasonal=TRUE)
fcast
fit_ets <- ets(training, model= "ZZN", damped = TRUE)
fcast
fit_ets <- ets(training, model= "ZNN", damped = FALSE)
fcast <- forecast(fit_ets,h, level=c(95))
fcast
fit_ets <- ets(training, model= "ZZN", damped = FALSE)
fcast
fit_ets <- ets(training, model= "ZZZ", damped = FALSE)
fcast
fit_ets <- ets(training, model= "ZZZ", damped = TRUE)
fcast <- forecast(fit_ets,h, level=c(95))
fcast
fit_ets <- ets(training, model= "ZNZ")
fcast
fcast <- snaive(training, h=h, level=c(95))
fcast
fcast <- rwf(training, drift = FALSE, h=h, level=c(95))
fcast
fcast <- rwf(training, drift = TRUE, h=h, level=c(95))
fcast
if(frequency(training)==1 | length(training) <= 2*frequency(training)){
fcast <- forecast(auto.arima(training, max.q=0), h=h, level=c(95))
} else {
fit_stlm <- stlm(training, modelfunction=ar)
fcast <- forecast(fit_stlm, h=h, level=c(95))
}
fcast <- forecast(auto.arima(training, max.q=0), h=h, level=c(95))
fcast
fit_stlm <- stlm(training, modelfunction=ar)
fcast <- forecast(fit_stlm, h=h, level=c(95))
fcast
# using stheta method with seasonal adjustment
# require(forecTheta)
fitTheta <- forecTheta::stm(training,h=h,  s='additive', level=c(80, 90, 95))
fcast <- list(mean=fitTheta$mean, lower = fitTheta$lower[,3], upper = fitTheta$upper[,3])
fcast
# using thetaf method
fcast <-forecast::thetaf(training,h=h, level=c(95))
fcast
fit_nnetar <- forecast::nnetar(training)
fcast
fcast$lower
fit_mstl <- stlf(training)
fcast <- forecast(fit_mstl, h=h, level=c(95))
fcast
fit_mstl <- stlf(training)
fcast <- forecast(fit_mstl, h=h, level=c(95))
fit_mstl <- stlf(training, method="arima")
fcast <- forecast(fit_mstl, h=h, level=c(95))
fit_tbats <- forecast::tbats(training)
fcast <- forecast(fit_tbats, h=h, level=c(95))
forecast(fit_mstl, h=h
)
forecast(fit_mstl, h=h, level=c(95))
fit_mstl <- stlf(training)
fcast1 <- forecast(fit_mstl, h=h)
fcast <- list(mean=fcast1$mean, lower = fcast1$lower[,3], upper = fcast1$upper[,3])
fcast1 <- forecast(fit_mstl, h=h)
fcast1$mean
fcast1$lower[,3]
fcast1$lower
?stlf
fit_mstl <- stlf(training, level=c(95))
fcast1 <- forecast(fit_mstl, h=h)
fcast1
fit_tbats <- forecast::tbats(training)
fcast
fit_wn <- Arima(training,order=c(0,0,0))
fcast
as.vector(fcast$mean)
as.vector(fcast$lower)
as.vector(fcast$upper)
accuracyFun(forecast=fcast$mean, training=training, test=test)
#' forecast-accuracy for the test set
#' @param predictions prediction results obtained from  random forest classifier
#' @param tslist list of new time series
#' @param database whethe the time series is from mcom or other
#' @param accuracy if true a accuaracy measure will be calculated
#' @param  function_name to calculate accuracy measure, the arguments for the
#' accuracy function should be training period, test period and forecast
#' @param h length of the forecast horizon
#' @return a numeric vector contains the forecast accuracy for each series
#' @export
rfprediction_accuracy <- function(predictions, tslist, database, function_name, h, accuracy){
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
total_ts <- length(train_test)
accuracy_value <- numeric(total_ts)
forecast_mean <- matrix(NA, nrow=total_ts, ncol=h)
forecast_lower <- matrix(NA, nrow=total_ts, ncol=h)
forecast_upper <- matrix(NA, nrow=total_ts, ncol=h)
accuracyFun <- match.fun(function_name)
for (i in 1:total_ts){
training <- train_test[[i]]$training
test <-  train_test[[i]]$test
m <- frequency(training)
if (predictions[i] == "ARIMA") {
fit_arima <- auto.arima(training, seasonal = FALSE)
fcast <- forecast(fit_arima,h, level=c(95))
} else if (predictions[i] == "ARMA/AR/MA") {
fit_arma <- auto.arima(training,d=0, stationary=TRUE, seasonal = FALSE)
fcast <- forecast(fit_arma,h, level=c(95))
}else if (predictions[i] == "SARIMA") {
fit_sarima <- auto.arima(training, seasonal=TRUE)
fcast <- forecast(fit_sarima,h, level=c(95))
}  else if (predictions[i] == "ETS-dampedtrend") {
fit_ets <- ets(training, model= "ZZN", damped = TRUE)
fcast <- forecast(fit_ets,h, level=c(95))
} else if (predictions[i] == "ETS-notrendnoseasonal") {
fit_ets <- ets(training, model= "ZNN", damped = FALSE)
fcast <- forecast(fit_ets,h, level=c(95))
} else if (predictions[i] == "ETS-trend") {
fit_ets <- ets(training, model= "ZZN", damped = FALSE)
fcast <- forecast(fit_ets,h, level=c(95))
} else if (predictions[i] == "ETS-trendseasonal") {
fit_ets <- ets(training, model= "ZZZ", damped = FALSE)
fcast <- forecast(fit_ets,h, level=c(95))
}else if (predictions[i] == "ETS-dampedtrendseasonal") {
fit_ets <- ets(training, model= "ZZZ", damped = TRUE)
fcast <- forecast(fit_ets,h, level=c(95))
}else if (predictions[i] == "ETS-seasonal") {
fit_ets <- ets(training, model= "ZNZ")
fcast <- forecast(fit_ets,h, level=c(95))
}else if (predictions[i] == "snaive") {
fcast <- snaive(training, h=h, level=c(95))
}else if (predictions[i] == "rw") {
fcast <- rwf(training, drift = FALSE, h=h, level=c(95))
} else if (predictions[i] == "rwd") {
fcast <- rwf(training, drift = TRUE, h=h, level=c(95))
} else if (predictions[i] == "stlar") {
if(frequency(training)==1 | length(training) <= 2*frequency(training)){
fcast <- forecast(auto.arima(training, max.q=0), h=h, level=c(95))
} else {
fit_stlm <- stlm(training, modelfunction=ar)
fcast <- forecast(fit_stlm, h=h, level=c(95))
}
} else if (predictions[i] == "theta") {
if (m > 1){
# using stheta method with seasonal adjustment
# require(forecTheta)
fitTheta <- forecTheta::stm(training,h=h,  s='additive', level=c(80, 90, 95))
fcast <- list(mean=fitTheta$mean, lower = fitTheta$lower[,3], upper = fitTheta$upper[,3])
}else{
# using thetaf method
fcast <-forecast::thetaf(training,h=h, level=c(95))
}
} else if (predictions[i] == "nn"){
fit_nnetar <- forecast::nnetar(training)
fcast <- forecast(fit_nnetar, PI=TRUE, h=h, level=c(95))
} else if (predictions[i] == "mstl"| predictions[i] == "mstlets"){
fit_mstl <- stlf(training, level=c(95))
fcast <- forecast(fit_mstl, h=h)
} else if (predictions[i] == "mstlarima"){
fit_mstl <- stlf(training, method="arima", level=c(95))
fcast <- forecast(fit_mstl, h=h)
} else if (predictions[i] == "tbats"){
fit_tbats <- forecast::tbats(training)
fcast <- forecast(fit_tbats, h=h, level=c(95))
} else {
fit_wn <- Arima(training,order=c(0,0,0))
fcast <- forecast(fit_wn,h, level=c(95))
}
forecast_mean[i,] <- as.vector(fcast$mean)
forecast_lower[i,] <- as.vector(fcast$lower)
forecast_upper[i,] <- as.vector(fcast$upper)
if(accuracy==TRUE){
accuracy_value[i] <- accuracyFun(forecast=fcast$mean, training=training, test=test)
}
}
forecast_results <- list(mean = forecast_mean, lower=forecast_lower, upper=forecast_upper)
return(forecast_results)
}
stl_df$seasonal_strength1[is.na(stl_df$seasonal_strength1)==TRUE] =
stl_df$seasonal_strength[is.na(stl_df$"seasonal_strength")==FALSE]
#' @param seasonal if FALSE, restricts to features suitable for non-seasonal data
#' @param m frequency of the time series or minimum frequency in the case of msts objects
#' @param lagmax maximum lag at which to calculate the acf (quarterly series-5L and monthly-13L)
#' @param database whether the time series is from mcomp or other
#' @param h forecast horizon
#' @param highfreq whether the time series is weekly, daily or hourly
#' @return dataframe: each column represent a feature and each row represent a time series
#' @importFrom magrittr %>%
#' @author Thiyanga Talagala
#' @export
cal_features <- function(tslist, seasonal=FALSE, m=1, lagmax=2L, database, h, highfreq){ # tslist = yearly_m1,
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
train <- lapply(train_test, function(temp){temp$training})
ts_features_pkg <- tsfeatures::tsfeatures(train, c("entropy",
"lumpiness",
"stability",
"hurst",
# "stl_features",
"acf_features",
"pacf_features",
"nonlinearity"))
# calculation of stl features: handling short and long time series
stl_ftrs <- lapply(train, function(temp){
length_temp <- length(temp)
# tryCatch({
#freq_temp <- frequency(temp)
freq_temp <- m
# }, error=function(e){freq_temp <- m})
required_length <- 2*freq_temp+1
if (length_temp > required_length) {tsfeatures::stl_features(temp)
} else {
fcast_h <- required_length-length_temp
fcast <- forecast::forecast(temp, fcast_h)$mean
com <- ts(c(temp,fcast), start=start(temp), frequency=frequency(temp))
tsfeatures::stl_features(com)
}
})
if (highfreq==FALSE){
stl_df <- as.data.frame(do.call("rbind", stl_ftrs))
} else {
stl_df <- dplyr::bind_rows(lapply(stl_ftrs, as.data.frame.list))
stl_df$seasonal_strength1[is.na(stl_df$seasonal_strength1)==TRUE] =
stl_df$seasonal_strength[is.na(stl_df$"seasonal_strength")==FALSE]
stl_df$seasonal_strength2[is.na(stl_df$seasonal_strength2)==TRUE]=0
stl_df <- subset(stl_df, select = -"seasonal_strength")
}
ts_features_pkg <- dplyr::bind_cols(ts_features_pkg,stl_df)
if (seasonal==FALSE){
ts_features1 <- ts_features_pkg %>% dplyr::select ("entropy", "lumpiness", "stability", "hurst",
"trend", "spike", "linearity", "curvature",
"e_acf1", "x_acf1", "diff1_acf1", "diff2_acf1",
"x_pacf5","diff1x_pacf5", "diff2x_pacf5", "nonlinearity")
seer_features_nonseasonal <- lapply(train, function(temp1){c(
seer::e_acf1(temp1),
seer::unitroot(temp1))})
seer_features_nonseasonal_DF <- as.data.frame(do.call("rbind", seer_features_nonseasonal))
ts_features <- dplyr::bind_cols(ts_features1, seer_features_nonseasonal_DF)
} else {
ts_features_pkg_name <- names(ts_features_pkg)
seasonalFeatures <- grep("seasonal_strength",ts_features_pkg_name, value = TRUE)
select_features <- c("entropy", "lumpiness", "stability", "hurst",
"trend", "spike", "linearity", "curvature",
"e_acf1", "x_acf1", "diff1_acf1", "diff2_acf1",
"x_pacf5","diff1x_pacf5", "diff2x_pacf5","nonlinearity",
"seas_pacf", seasonalFeatures)
ts_features1 <- ts_features_pkg %>% dplyr::select (select_features)
if(highfreq==TRUE){
seer_features_seasonal <- lapply(train, function(temp1){
acf_seasonalDiff(temp1, m, lagmax)})
} else {
seer_features_seasonal <- lapply(train, function(temp1){c(seer::holtWinter_parameters(temp1),
acf_seasonalDiff(temp1, m, lagmax))})
}
seer_features_seasonal_DF <- as.data.frame(do.call("rbind", seer_features_seasonal))
ts_features <- dplyr::bind_cols(ts_features1, seer_features_seasonal_DF)
}
ts_featuresDF <- as.data.frame(ts_features)
ts_featuresDF <- dplyr::rename(ts_featuresDF, "spikiness" = "spike")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "y_acf1" = "x_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff1y_acf1" = "diff1_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff2y_acf1" = "diff2_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "y_pacf5" = "x_pacf5")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff1y_pacf5" = "diff1x_pacf5")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff2y_pacf5" = "diff2x_pacf5")
names_slt_df <- names(stl_df)
if("seasonal_strength" %in% names_slt_df ==TRUE){
ts_featuresDF <- dplyr::rename(ts_featuresDF, "seasonality" = "seasonal_strength")
}
length <- lapply(train, function(temp){length(temp)})
length <- unlist(length)
ts_featuresDF$N <- length
if (highfreq==FALSE){
seer_features <- lapply(train, function(temp1){c(seer::acf5(temp1), seer::holt_parameters(temp1))})
} else {
seer_features <- lapply(train, function(temp1){seer::acf5(temp1)})
}
seer_feature_DF <- as.data.frame(do.call("rbind", seer_features))
featureDF <- dplyr::bind_cols(ts_featuresDF,seer_feature_DF)
return(featureDF)
}
#'@examples
require(Mcomp)
data(M3)
yearly_m3 <- subset(M3, "yearly")
cal_features(yearly_m3, database="M3", h=6, highfreq=FALSE)
head(stl_df)
stl_df <- stl_df %>%  dplyr::select(-c("seasonal_strength"))
iris %>% select (-c(Sepal.Length, Sepal.Width))
iris %>% select (-c(Sepal.Length))
stl_df <- as.data.frame(do.call("rbind", stl_ftrs))
stl_df <- dplyr::bind_rows(lapply(stl_ftrs, as.data.frame.list))
stl_df$seasonal_strength1[is.na(stl_df$seasonal_strength1)==TRUE] =
stl_df$seasonal_strength[is.na(stl_df$"seasonal_strength")==FALSE]
stl_df$seasonal_strength2[is.na(stl_df$seasonal_strength2)==TRUE]=0
stl_df <- stl_df %>%  dplyr::select(-c("seasonal_strength"))
drop <- c("seasonal_strength")
stl_df <- stl_df %>%  dplyr::select(-drop)
stl_df <- stl_df %>% dplyr::select(-drop)
stl_df <- dplyr::bind_rows(lapply(stl_ftrs, as.data.frame.list))
stl_df$seasonal_strength1[is.na(stl_df$seasonal_strength1)==TRUE] =
stl_df$seasonal_strength[is.na(stl_df$"seasonal_strength")==FALSE]
stl_df$seasonal_strength2[is.na(stl_df$seasonal_strength2)==TRUE]=0
names( stl_df)
stl_df <- stl_df[, -"seasonal_strength"]
stl_df <- stl_df %>% dplyr::select(-one_of("seasonal_strength"))
names( stl_df)
?one_of
rm(list=ls())
library(seer)
a=6
b=6
a>=b
library(seer)
library(seer)
a <- numeric(5)
a
library(seer)
library(seer)
library(seer)
library(seer)
training <- rnorm(20)
fit_nnetar <- forecast::nnetar(training)
training <- rnorm(5)
fit_nnetar <- forecast::nnetar(training)
fcast <- forecast(fit_nnetar, PI=TRUE, h=h, level=c(95))
library(forecast)
fcast <- forecast(fit_nnetar, PI=TRUE, h=h, level=c(95))
h=14
fit_nnetar <- forecast::nnetar(training)
fcast <- forecast(fit_nnetar, PI=TRUE, h=h, level=c(95))
tryCatch({
fit_nnetar <- forecast::nnetar(training)
fcast <- forecast(fit_nnetar, PI=TRUE, h=h, level=c(95))
}, error=function(e){fcast <- snaive(training, h=h, level=c(95))})
training <- rnorm(5)
training <- as.ts(training, frequency=12)
fit_nnetar <- forecast::nnetar(training)
fcast <- forecast(fit_nnetar, PI=TRUE, h=h, level=c(95))
library(seer)
library(seer)
library(seer)
#' @param tslist a list of time series
#' @param models a vector of models to compute
#' @param database whether the time series is from mcomp or other
#' @param accuracyFun function to calculate the accuracy measure, the arguments
#' for the accuracy function should be training, test and forecast
#' @param h forecast horizon
#' @param length_out number of measures calculated by a single function
#' @return a list with accuracy matrix, vector of arima models and vector of ets models
#' @author Thiyanga Talagala
#' @export
fcast_accuracy <- function(tslist, models = c("ets", "arima", "rw", "rwd", "wn",
"theta", "stlar", "nn", "snaive", "mstlarima","mstlets", "tbats"), database
, accuracyFun, h, length_out){
arima_models <- NA
ets_models <- NA
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
if ("arima"%in% models) {
arima_cal <- lapply(train_test, accuracy_arima, function_name=accuracyFun)
arima_models <- sapply(arima_cal, function(temp){temp$ARIMAmodel})
}
if ("ets"%in% models) {
ets_cal <- lapply(train_test, accuracy_ets, function_name=accuracyFun)
ets_models <- sapply(ets_cal, function(temp){temp$ETSmodel})
}
mat <- sapply(models, function(f){
switch(f,
arima = sapply(arima_cal, function(temp){temp$ARIMAaccuracy}),
ets = sapply(ets_cal, function(temp){temp$ETSaccuracy}),
rw = sapply(train_test, accuracy_rw, function_name=accuracyFun),
rwd = sapply(train_test, accuracy_rwd, function_name=accuracyFun, length_out=length_out),
wn = sapply(train_test, accuracy_wn, function_name=accuracyFun, length_out=length_out),
theta = sapply(train_test, accuracy_theta, function_name=accuracyFun, length_out=length_out),
stlar = sapply(train_test, accuracy_stlar, function_name=accuracyFun, length_out=length_out),
nn = sapply(train_test, accuracy_nn, function_name=accuracyFun, length_out=length_out),
snaive = sapply(train_test, accuracy_snaive, function_name=accuracyFun, length_out=length_out),
mstlets = sapply(train_test, accuracy_mstl, function_name=accuracyFun, length_out=length_out, mtd="ets"),
mstlarima = sapply(train_test, accuracy_mstl, function_name=accuracyFun, length_out=length_out, mtd="arima"),
tbats = sapply(train_test, accuracy_tbats, function_name=accuracyFun, length_out=length_out)
)
})
return(list(accuracy=mat, ARIMA = arima_models, ETS =ets_models))
}
#'@examples
library(Mcomp)
tslist <- list(M3[[1]], M3[[2]])
fcast_accuracy(tslist=tslist,models= c("arima","ets","rw","rwd", "theta", "stlar", "nn", "snaive", "mstl"),database ="M3", cal_MASE, h=6)
library(seer)
