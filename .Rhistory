}
return(y)
)
}
6 < 8 <9
a=8
6 < a < 9
6<a<9
convert_msts <- function(y, category){
switch(category,
daily={
if( length(y) <= 366){
y <- ts(y, frequency = 7)
} else {
y <- forecast::msts(y, seasonal.periods=c(7, 365.25))
}
},
hourly={
if (length(y) > 8766){
y <- forecast::msts(y, seasonal.periods=c(24, 168, 8766))
} else if( 168 < length(y) & length(y) <= 8766) {
y <- forecast::msts(y, seasonal.periods=c(24, 168))
} else {
y <- ts(y, frequency=24)
}
}
return(y)
)
}
convert_msts <- function(y, category){
switch(category,
daily={
if( length(y) <= 366){
y <- ts(y, frequency = 7)
} else {
y <- forecast::msts(y, seasonal.periods=c(7, 365.25))
}
},
hourly={
if (length(y) > 8766){
y <- forecast::msts(y, seasonal.periods=c(24, 168, 8766))
} else if( 168 < length(y) & length(y) <= 8766) {
y <- forecast::msts(y, seasonal.periods=c(24, 168))
} else {
y <- ts(y, frequency=24)
}
}
)
return(y)
}
library(seer)
M4_daily <- subset(M4, "daily")
data(M4)
M4_daily <- subset(M4, "daily")
M4_daily[[1]]$x
length(M4_daily[[1]]$x)
convert_msts(M4_daily[[1]]$x, daily)
convert_msts(M4_daily[[1]]$x, "daily")
a <- convert_msts(M4_daily[[1]]$x, "daily")
class(a)
library(seer)
library(seer)
library(seer)
library(seer)
library(forecast)
?stlf
#' @param Future if future=TRUE, the simulated observations are conditional on the historical observations.
#' In other words, they are possible future sample paths of the time series. But if future=FALSE, the historical
#' data are ignored, and the simulations are possible realizations of the time series model that
#' are not connected to the original data.
#' @param Length length of the simulated time series. If future = FALSE, the Length agument should be NA.
#' @param Method method to use for forecasting seasonally adjusted time series
#' @param extralength extra length need to be added for simulated time series
#' @return A list of time series.
#' @author Thiyanga Talagala
#' @export
sim_mstlbasedets <- function(y, Nsim, Combine=TRUE, M=TRUE, Future=FALSE, Length=NA, extralength=NA, Method){
if (M ==TRUE){
if ("Combine"==TRUE){
train <- y$x
test <-  y$xx
combined <- ts.union(train, test)
combined <- pmin(combined[,1], combined[,2], na.rm = TRUE)
}else{
combined <- y$x}
}else{
combined <- y
}
if(frequency(combined)==1 | length(combined) <= 2*frequency(combined))
return(NA)
fit <- forecast::stlf(combined, method=Method)
if (!is.na(Length)){length_series <- Length
} else if (!is.na(extralength)) {
length_series <- length(combined)+extralength
} else {
length_series <- length(combined)
}
mat <- list()
for(i in 1:Nsim){
mat[[i]] <- simulate(fit$model, nsim=length_series, future=Future)}
return (mat)
}
#'@examples
library(seer)
data(M4)
weekly_m4 <- subset(M4, "weekly")
sim_mstlbased(weekly_m4[[1]], 2, Combine=FALSE, M=TRUE, Future=FALSE, Method=ets)
#' @param Future if future=TRUE, the simulated observations are conditional on the historical observations.
#' In other words, they are possible future sample paths of the time series. But if future=FALSE, the historical
#' data are ignored, and the simulations are possible realizations of the time series model that
#' are not connected to the original data.
#' @param Length length of the simulated time series. If future = FALSE, the Length agument should be NA.
#' @param mtd method to use for forecasting seasonally adjusted time series
#' @param extralength extra length need to be added for simulated time series
#' @return A list of time series.
#' @author Thiyanga Talagala
#' @export
sim_mstlbased <- function(y, Nsim, Combine=TRUE, M=TRUE, Future=FALSE, Length=NA, extralength=NA, mtd){
if (M ==TRUE){
if ("Combine"==TRUE){
train <- y$x
test <-  y$xx
combined <- ts.union(train, test)
combined <- pmin(combined[,1], combined[,2], na.rm = TRUE)
}else{
combined <- y$x}
}else{
combined <- y
}
if(frequency(combined)==1 | length(combined) <= 2*frequency(combined))
return(NA)
fit <- forecast::stlf(combined, method=mtd)
if (!is.na(Length)){length_series <- Length
} else if (!is.na(extralength)) {
length_series <- length(combined)+extralength
} else {
length_series <- length(combined)
}
mat <- list()
for(i in 1:Nsim){
mat[[i]] <- simulate(fit$model, nsim=length_series, future=Future)}
return (mat)
}
#'@examples
library(seer)
data(M4)
weekly_m4 <- subset(M4, "weekly")
sim_mstlbased(weekly_m4[[1]], 2, Combine=FALSE, M=TRUE, Future=FALSE, mtd="arima")
a <- sim_mstlbased(weekly_m4[[1]], 2, Combine=FALSE, M=TRUE, Future=FALSE, mtd="arima")
class(a)
class(a[[1]])
class(a[[2]])
m4w1_msts <- convert_msts(weekly_m4[[1]]$x)
?stlf
tsmod <- stlm(USAccDeaths, modelfunction=ar)
plot(forecast(tsmod, h=36))
head(tsmod)
head(tsmod$stl)
tsmod <- stlar(USAccDeaths)
tsmod2 <- stlar(USAccDeaths)
head(tsmod2)
head(tsmod2$mean)
tsmod <- stlar(USAccDeaths)
tsmod <- stlm(USAccDeaths, modelfunction=ar)
forecast(tsmod$model, h=1)
plot(USAccDeaths)
class(USAccDeaths)
#' forecast seasonally adjusted data, while the seasonal naive method is used to forecast
#' the seasonal component
#' @param y a univariate time series
#' @param h forecast horizon
#' @param s.window Either the character string “periodic” or the span (in lags) of the loess window for seasonal extraction
#' @param robust logical indicating if robust fitting be used in the loess procedue
#' @return return object of class forecast
#' @author Thiyanga Talagala
#' @import forecast
#' @export
stlar <- function(y, h=10, s.window=11, robust=FALSE)
{
if(!is.ts(y))
y <- ts(y, frequency=findfrequency(y))
if(frequency(y)==1 | length(y) <= 2*frequency(y))
return(forecast(auto.arima(y, max.q=0), h=h))
fit_stlm <- stlm(y,s.window=s.window, robust=robust, modelfunction=ar)
fcast <- forecast(fit_stlm, h=h)
return(fcast)
}
tsmod2 <- stlar(USAccDeaths)
tsmod2
?stlm
stlm
tsmod <- stlar(USAccDeaths)
head(tsmod$method)
head(tsmod$odel)
tsmod2 <- stlar(USAccDeaths)
a <- forecast(tsmod2$method, 2)
a <- forecast(tsmod2$model, 2)
a
tsmod <- stlm(USAccDeaths, modelfunction=ar)
forecast(tsmod, h=2)
tsmod <- stlm(USAccDeaths, modelfunction=ar, s.window = 13)
a <- forecast(tsmod2$model, 2)
a
?stlm
?mstl
?stlf
?forecast
forecast(rnorm(10), h=2)
training <- rnorm(100)
fit_mstl <- forecast::mstl(training, mtd)
fit_mstl <- forecast::mstl(training, "ets")
fit_mstl <- forecast::mstl(training)
forecast(fit_mstl, h=2)
mtd = "ets"
fit_mstl <- forecast::mstl(training, method=mtd)
test <- rnorm(5)
forecast(fit_mstl, h=length(test))$mean
forecast(training, h=5)
library(seer)
data(M4)
a <- M4[["D1"]]$x
a <- msts(a, seasonal.periods = c(7,24))
forecast(a, h=5)
fit <- mstl(a)
forecast(fit, h=5)
fit <- mstl(a, method="arima")
?mstl
stlf(Training)
stlf(training)
training <- rnorm(15)
stlf(training)
?stlf
fit_mstl <- forecast::mstl(training)
fit_mstl$model
fit_mstl
class(fit_mstl)
?forecast
stlm(rnorm(20))
?forecast
m4_weekly <- subset(M4, "weeklt")
m4_weekly <- subset(M4, "weekly")
fit1 <- stlf(m4_weekly[[1]]$x)
fcast1 <- forecast(fit1, h=2)
fcast1
fit2 <- ets(m4_weekly[[1]]$x)
#' Calculate accuracy based on MSTL
#' @param ts_info list containing training and test part of a time series
#' @param function_name function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @param length_out number of measures calculated by the function
#' @return accuracy measure calculated based on multiple seasonal decomposition
#' @export
accuracy_mstl <- function(ts_info, function_name, length_out){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
tryCatch({
fit_stlf <- forecast::stlf(training)
forecastMSTL <- forecast(fit_stlf, h=length(test))$mean
ACCURACY <- match.fun(function_name)
MSTLaccuracy <- ACCURACY(forecast=forecastMSTL, test=test, training=training)
return(MSTLaccuracy)
}, error=function(e){return(rep(NA, length_out))})
}
function_name=cal_m4measures
length_out <- 2
tsinfo <- list(training=rnorm(15), test=rnorm(5))
#' Calculate accuracy based on MSTL
#' @param ts_info list containing training and test part of a time series
#' @param function_name function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @param length_out number of measures calculated by the function
#' @return accuracy measure calculated based on multiple seasonal decomposition
#' @export
accuracy_mstl <- function(ts_info, function_name, length_out){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
tryCatch({
fit_stlf <- forecast::stlf(training)
forecastMSTL <- forecast(fit_stlf, h=length(test))$mean
ACCURACY <- match.fun(function_name)
MSTLaccuracy <- ACCURACY(forecast=forecastMSTL, test=test, training=training)
return(MSTLaccuracy)
}, error=function(e){return(rep(NA, length_out))})
}
accuracy_mstl(ts_info, cal_m4measures, length_out = 2)
ts_info <- list(training=rnorm(15), test=rnorm(5))
accuracy_mstl(ts_info, cal_m4measures, length_out = 2)
library(Mcomp)
m3_monthly <- subset(M3, "monthly")
training <- m3_monthly[[1]]$x
test <- m3_monthly[[1]]$xx
ts_info <- list(training=training, test=test)
accuracy_mstl(ts_info, cal_m4measures, length_out = 2)
?stlf
library(seer)
#' @param seasonal if FALSE, restricts to features suitable for non-seasonal data
#' @param m frequency of the time series
#' @param lagmax maximum lag at which to calculate the acf (quarterly series-5L and monthly-13L)
#' @param database whether the time series is from mcomp or other
#' @param h forecast horizon
#' @param highfeq whether the time series is weekly, daily or hourly
#' @return dataframe: each column represent a feature and each row represent a time series
#' @importFrom magrittr %>%
#' @author Thiyanga Talagala
#' @export
cal_features <- function(tslist, seasonal=FALSE, m=1, lagmax=2L, database, h, highfreq){ # tslist = yearly_m1,
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
train <- lapply(train_test, function(temp){temp$training})
ts_features_pkg <- tsfeatures::tsfeatures(train, c("entropy",
"lumpiness",
"stability",
"hurst",
"stl_features",
"acf_features",
"pacf_features",
"nonlinearity"))
if (seasonal==FALSE){
ts_features1 <- ts_features_pkg %>% dplyr::select ("entropy", "lumpiness", "stability", "hurst",
"trend", "spike", "linearity", "curvature",
"e_acf1", "x_acf1", "diff1_acf1", "diff2_acf1",
"x_pacf5","diff1x_pacf5", "diff2x_pacf5", "nonlinearity")
seer_features_nonseasonal <- lapply(train, function(temp1){c(
seer::e_acf1(temp1),
seer::unitroot(temp1))})
seer_features_nonseasonal_DF <- as.data.frame(do.call("rbind", seer_features_nonseasonal))
ts_features <- dplyr::bind_cols(ts_features1, seer_features_nonseasonal_DF)
} else {
ts_features1 <- ts_features_pkg %>% dplyr::select ("entropy", "lumpiness", "stability", "hurst",
"trend", "spike", "linearity", "curvature",
"e_acf1", "x_acf1", "diff1_acf1", "diff2_acf1",
"x_pacf5","diff1x_pacf5", "diff2x_pacf5","nonlinearity", "seasonal_strength",
"seas_pacf")
if(highfreq==TRUE){
seer_features_seasonal <- lapply(train, function(temp1){
acf_seasonalDiff(temp1, m, lagmax)})
} else {
seer_features_seasonal <- lapply(train, function(temp1){c(seer::holtWinter_parameters(temp1),
acf_seasonalDiff(temp1, m, lagmax))})
}
seer_features_seasonal_DF <- as.data.frame(do.call("rbind", seer_features_seasonal))
ts_features <- dplyr::bind_cols(ts_features1, seer_features_seasonal_DF)
}
ts_featuresDF <- as.data.frame(ts_features)
ts_featuresDF <- dplyr::rename(ts_featuresDF, "spikiness" = "spike")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "y_acf1" = "x_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff1y_acf1" = "diff1_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff2y_acf1" = "diff2_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "y_pacf5" = "x_pacf5")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff1y_pacf5" = "diff1x_pacf5")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff2y_pacf5" = "diff2x_pacf5")
if(seasonal==TRUE){
ts_featuresDF <- dplyr::rename(ts_featuresDF, "seasonality" = "seasonal_strength")
}
length <- lapply(train, function(temp){length(temp)})
length <- unlist(length)
ts_featuresDF$N <- length
if (highfreq==TRUE){
seer_features <- lapply(train, function(temp1){c(seer::acf5(temp1), seer::holt_parameters(temp1))})
} else {
seer_features <- lapply(train, function(temp1){seer::acf5(temp1)})
}
seer_feature_DF <- as.data.frame(do.call("rbind", seer_features))
featureDF <- dplyr::bind_cols(ts_featuresDF,seer_feature_DF)
return(featureDF)
}
#'@examples
require(Mcomp)
data(M3)
yearly_m3 <- subset(M3, "yearly")
cal_features(yearly_m3, database="M3", h=6, highfreq=FALSE)
library(tsfeatures)
library(forecast)
#'@examples
require(Mcomp)
data(M3)
yearly_m3 <- subset(M3, "yearly")
cal_features(yearly_m3, database="M3", h=6, highfreq=FALSE)
library(seer)
data("M4")
d1 <- subset(M4, "daily")
plot(d[[1]]$x)
plot(d1[[1]]$x)
acf(d1[[1]]$x)
frequency(d1[[1]]$x)
s1 <- diff(d[[1]]$x, lag=365, differences = 1)
s1 <- diff(d1[[1]]$x, lag=365, differences = 1)
acf(s1)
acf(d1[[1]]$x)
acf(s1)
acf(d1[[2]]$x)
acf(d1[[3]]$x)
s1 <- diff(d1[[3]]$x, lag=365, differences = 1)
acf(S1)
acf(s1)
s1
s1 <- diff(d1[[3]]$x, lag=365, differences = 1)
s1
acf(d1[[4]]$x)
acf(d1[[5]]$x)
acf(d1[[6]]$x)
acf(d1[[7]]$x)
acf(d1[[8]]$x)
acf(d1[[9]]$x)
acf(d1[[10]]$x)
acf(d1[[11]]$x)
acf(d1[[12]]$x)
acf(d1[[13]]$x)
acf(d1[[14]]$x)
acf(d1[[15]]$x)
plot(d1[[15]]$x)
s1 <- diff(d1[[3]]$x, lag=7, differences = 1)
acf(s1)
s1 <- diff(d1[[1]]$x, lag=7, differences = 1)
acf(s1)
ets(d1[[1]]$x)
ets(d1[[3]]$x)
ets(d1[[4]]$x)
plot(d1[[4]]$x)
frequency(d1[[4]]$x)
ets(d1[[5]]$x)
length(d1[[5]]$x)
ets(d1[[6]]$x)
library(seer)
library(seer)
library(seer)
install.packages("ggplot2")
library(ggplot2)
install.packages("forecast")
library(seer)
data(M4)
M4_weekly <- subset(M4, "weekly")
sl <- sapply(M4_weekly, function(temp){length(temp$x)})
which(s1==80)
s1
which(sl==80)
aa <- M4_weekly[[295]]
aa
train <- aa$x
length(train)
# calculation of stl features: handling short and long time series
stl_ftrs <- lapply(train, function(temp){
length_temp <- length(temp)
required_length <- 2*frequency(temp)
if (length_temp > required_length) {tsfeatures::stl_features(temp)
} else {
fcast_h <- required_length-length_temp
fcast <- forecast::forecast(temp, fcast_h)$mean
com <- ts(c(temp,fcast), start=start(temp), frequency=frequency(temp))
tsfeatures::stl_features(temp)
}
})
temp <- train
length_temp <- length(temp)
required_length <- 2*frequency(temp)
length_temp > required_length
# calculation of stl features: handling short and long time series
stl_ftrs <- lapply(train, function(temp){
length_temp <- length(temp)
required_length <- 2*frequency(temp)
if (length_temp > required_length) {tsfeatures::stl_features(temp)
} else {
fcast_h <- required_length-length_temp
fcast <- forecast::forecast(temp, fcast_h)$mean
com <- ts(c(temp,fcast), start=start(temp), frequency=frequency(temp))
tsfeatures::stl_features(com)
}
})
train
# calculation of stl features: handling short and long time series
stl_ftrs <- lapply(train, function(temp){
length_temp <- length(temp)
required_length <- 2*frequency(temp)
if (length_temp > required_length) {tsfeatures::stl_features(temp)
} else {
fcast_h <- required_length-length_temp
fcast <- forecast::forecast(temp, fcast_h)$mean
com <- ts(c(temp,fcast), start=start(temp), frequency=frequency(temp))
tsfeatures::stl_features(com)
}
})
length_temp <- length(temp)
required_length <- 2*frequency(temp)
required_length
length_temp
length_temp > required_length
fcast_h <- required_length-length_temp
fcast_h
fcast <- forecast::forecast(temp, fcast_h)$mean
com <- ts(c(temp,fcast), start=start(temp), frequency=frequency(temp))
length(com)
tsfeatures::stl_features(com)
# calculation of stl features: handling short and long time series
stl_ftrs <- lapply(train, function(temp){
length_temp <- length(temp)
required_length <- 2*frequency(temp)+1
if (length_temp > required_length) {tsfeatures::stl_features(temp)
} else {
fcast_h <- required_length-length_temp
fcast <- forecast::forecast(temp, fcast_h)$mean
com <- ts(c(temp,fcast), start=start(temp), frequency=frequency(temp))
tsfeatures::stl_features(com)
}
})
library(seer)
library(seer)
library(seer)
