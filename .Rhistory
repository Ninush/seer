#' @param h forecast horizon
#' @return a list with accuracy matrix, vector of arima models and vector of ets models
#' @author Thiyanga Talagala
#' @export
fcast_accuracy <- function(tslist, models = c("ets", "arima", "rw", "rwd", "wn",
"theta", "stlar", "nn", "snaive", "mstl", "tbats"), database
, accuracyFun, h){
arima_models <- NA
ets_models <- NA
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
if ("arima"%in% models) {
arima_cal <- lapply(train_test, accuracy_arima, function_name=accuracyFun)
arima_models <- sapply(arima_cal, function(temp){temp$ARIMAmodel})
}
if ("ets"%in% models) {
ets_cal <- lapply(train_test, accuracy_ets, function_name=accuracyFun)
ets_models <- sapply(ets_cal, function(temp){temp$ETSmodel})
}
mat <- sapply(models, function(f){
switch(f,
arima = sapply(arima_cal, function(temp){temp$ARIMAaccuracy}),
ets = sapply(ets_cal, function(temp){temp$ETSaccuracy}),
rw = sapply(train_test, accuracy_rw, function_name=accuracyFun),
rwd = sapply(train_test, accuracy_rwd, function_name=accuracyFun),
wn = sapply(train_test, accuracy_wn, function_name=accuracyFun),
theta = sapply(train_test, accuracy_theta, function_name=accuracyFun),
stlar = sapply(train_test, accuracy_stlar, function_name=accuracyFun),
nn = sapply(train_test, accuracy_nn, function_name=accuracyFun),
snaive = sapply(train_test, accuracy_snaive, function_name=accuracyFun),
mstl = sapply(train_test, accuracy_mstl, function_name=accuracyFun),
tbats = sapply(train_test, accuracy_tbats, function_name=accuracyFun)
)
})
return(list(accuracy=mat, ARIMA = arima_models, ETS =ets_models))
}
#'@examples
library(Mcomp)
tslist <- list(M3[[1]], M3[[2]])
fcast_accuracy(tslist=tslist,models= c("arima","ets","rw","rwd", "theta", "stlar", "nn", "snaive", "mstl"),database ="M3", cal_avg, h=6)
#' Forecast-accuracy calculation
#'
#' Calculate accuracy measure based on ETS models
#' @param ts_info list containing training and test part of a time series
#' @param function_name function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @return a list which contains the accuracy and name of the specific ETS model.
#' @export
accuracy_ets <- function(ts_info, function_name){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
ets_fit <- forecast::ets(training)
forecastETS <- forecast(ets_fit,h)$mean
ACCURACY <- match.fun(function_name)
ETSaccuracy <- ACCURACY(forecast=forecastETS,test=test, training=training)
ETSmodel <- as.character(ets_fit)
return(list(ETSmodel=ETSmodel, ETSaccuracy=ETSaccuracy))
}
#' Calculate accuracy measue based on ARIMA models
#' @param ts_info list containing training and test part of a time series
#' @param function_name function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @return a list which contains the accuracy and name of the specific ARIMA model.
#' @export
accuracy_arima <- function(ts_info, function_name){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
arima_fit <- forecast::auto.arima(training)
forecastARIMA <- forecast(arima_fit,h)$mean
ACCURACY <- match.fun(function_name)
ARIMAaccuracy <- ACCURACY(forecast=forecastARIMA, test=test, training=training)
ARIMAmodel <- as.character(arima_fit)
return(list(ARIMAmodel=ARIMAmodel, ARIMAaccuracy=ARIMAaccuracy))
}
#' Calculate accuracy measure based on random walk models
#' @param ts_info list containing training and test part of a time series
#' @param function_name function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @return returns accuracy measure calculated baded on random walk model
#' @export
accuracy_rw <- function(ts_info, function_name){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
rw_fit <- forecast::rwf(training,drift=FALSE, h=h)
forecastRW <- forecast(rw_fit)$mean
ACCURACY <- match.fun(function_name)
RWaccuracy <- ACCURACY(forecast=forecastRW,test=test, training=training)
return(RWaccuracy)
}
#' Calculate accuracy measure based on random walk with drift
#' @param ts_info list containing training and test part of a time series
#' @param function_name function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @return accuracy measure calculated baded on random walk with drift model
#' @export
accuracy_rwd <- function(ts_info, function_name){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
if (forecast::is.constant(training)==TRUE){return(NA)}
tryCatch({
rwd_fit <- rwf(training,drift=TRUE, h=h)
forecastRWD <- forecast(rwd_fit)$mean
ACCURACY <- match.fun(function_name)
RWDaccuracy <- ACCURACY(forecast=forecastRWD, test=test, training=training)
return(RWDaccuracy)
}, error=function(e){return(NA)})
}
#' Calculate accuracy measure based on white noise process
#' @param ts_info list containing training and test part of a time series
#' @param function_name function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @return returns accuracy measure calculated based on white noise process
#' @export
accuracy_wn <- function(ts_info, function_name){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
tryCatch({
fit_WN <- forecast::auto.arima(training, d=0, D=0, max.p=0, max.q = 0,
max.Q=0, max.P = 0)
forecastWN <- forecast(fit_WN,h)$mean
ACCURACY <- match.fun(function_name)
WNaccuracy <- ACCURACY(forecast=forecastWN,test=test, training=training)
return(WNaccuracy)
}, error=function(e){return(NULL)})
}
#' Calculate accuracy measure based on Theta method
#' @param ts_info list containing training and test part of a time series
#' @param function_name function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @return returns accuracy measure calculated based on theta method
#' @export
accuracy_theta <- function(ts_info, function_name){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
m <- frequency(training)
ACCURACY <- match.fun(function_name)
tryCatch({
if (m > 1){
# using stheta method with seasonal adjustment
# require(forecTheta)
forecastTheta <- forecTheta::stheta(training,h=h, s='additive')$mean
THETAaccuracy <- ACCURACY(forecast=forecastTheta, test=test, training=training)
} else {
# using thetaf method
forecastTheta <-forecast::thetaf(training,h=length(test))$mean
THETAaccuracy <- ACCURACY(forecast=forecastTheta, test=test, training=training)
}
return(THETAaccuracy)
}, error=function(e){return(NULL)})
}
#' Calculate accuracy measure based on STL-AR method
#' @param ts_info list containing training and test part of a time series
#' @param function_name function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @return accuracy measure calculated based on stlar method
#' @export
accuracy_stlar <- function(ts_info, function_name){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
forecastSTLAR <- stlar(training,h=h)$mean
ACCURACY <- match.fun(function_name)
tryCatch({
STLARaccuracy <- ACCURACY(forecast=forecastSTLAR, test=test, training=training)
return(STLARaccuracy)
}, error=function(e){return(NULL)})
}
#' Calculate accuracy measure calculated based on neural network forecasts
#' @param ts_info list containing training and test part of a time series
#' @param function_name function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @return accuracy measure calculated based on neural network forecasts
#' @export
accuracy_nn <- function(ts_info, function_name){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
tryCatch({
fit_nnetar <- forecast::nnetar(training)
forecastnnetar <- forecast(fit_nnetar, h=h)$mean
ACCURACY <- match.fun(function_name)
nnetarACCURACY <- ACCURACY(forecast=forecastnnetar, test=test, training=training)
return(nnetarACCURACY)
}, error=function(e){return(NULL)})
}
#' Calculate accuracy measure based on snaive method
#' @param ts_info list containing training and test part of a time series
#' @param function_name function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @return accuracy measure calculated based on snaive method
#' @export
accuracy_snaive <- function(ts_info, function_name){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
tryCatch({
forecastSNAIVE <- forecast::snaive(training, h=length(test))$mean
ACCURACY <- match.fun(function_name)
SNAIVEaccuracy <- ACCURACY(forecast=forecastSNAIVE, test=test, training=training)
return(SNAIVEaccuracy)
}, error=function(e){return(NULL)})
}
#' Calculate accuracy based on MSTL
#' @param ts_info list containing training and test part of a time series
#' @param function_name function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @return accuracy measure calculated based on multiple seasonal decomposition
#' @export
accuracy_mstl <- function(ts_info, function_name){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
tryCatch({
fit_mstl <- forecast::mstl(training)
forecastMSTL <- forecast(training, h=length(test))$mean
ACCURACY <- match.fun(function_name)
MSTLaccuracy <- ACCURACY(forecast=forecastMSTL, test=test, training=training)
return(MSTLaccuracy)
}, error=function(e){return(NULL)})
}
#' Calculate accuracy measure based on TBATS
#' @param ts_info list containing training and test part of a time series
#' @param function_name function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @return accuracy measure calculated based on TBATS models
#' @export
accuracy_tbats <- function(ts_info, function_name){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
ACCURACY <- match.fun(function_name)
tryCatch({
fitTBAT <- forecast::tbats(training)
forecastTBATS <- forecast(fitTBAT, h=h)$mean
TBATSaccuracy <- ACCURACY(forecast=forecastTBATS, test=test, training=training)
return(TBATSaccuracy)
}, error=function(e){return(NULL)})
}
fcast_accuracy(tslist=tslist,models= c("arima","ets","rw","rwd", "theta", "stlar", "nn", "snaive", "mstl"),database ="M3", cal_avg, h=6)
tslist <- list(M3[[1]], M3[[2]])
models= c("arima","ets","rw","rwd", "theta", "stlar", "nn", "snaive", "mstl")
arima_models <- NA
ets_models <- NA
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
database="M3"
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
if ("arima"%in% models) {
arima_cal <- lapply(train_test, accuracy_arima, function_name=accuracyFun)
arima_models <- sapply(arima_cal, function(temp){temp$ARIMAmodel})
}
accuracyFun <- cal_avg()
accuracyFun <- cal_avg
cal_avg
#'@param forecast forecast obtained from a fitted to the training period
#'@return returns a single value: mean on MASE and sMAPE
#'@author Thiyanga Talagala
#'@export
#'@examples
#'require(Mcomp)
#'require(magrittr)
#'ts <- M3[[1]]$x
#'fcast_arima <- auto.arima(ts) %>% forecast(h=6)
#'cal_avg(M3[[1]]$x, M3[[1]]$xx, fcast_arima$mean)
cal_avg <- function(training, test, forecast){
method_MASE <- cal_MASE(training, test, forecast)
method_sMAPE <- cal_sMAPE(training, test, forecast)
avg <- c(method_MASE, method_sMAPE)
return(avg)
}
accuracyFun <- cal_avg
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
if ("arima"%in% models) {
arima_cal <- lapply(train_test, accuracy_arima, function_name=accuracyFun)
arima_models <- sapply(arima_cal, function(temp){temp$ARIMAmodel})
}
if ("ets"%in% models) {
ets_cal <- lapply(train_test, accuracy_ets, function_name=accuracyFun)
ets_models <- sapply(ets_cal, function(temp){temp$ETSmodel})
}
mat <- sapply(models, function(f){
switch(f,
arima = sapply(arima_cal, function(temp){temp$ARIMAaccuracy}),
ets = sapply(ets_cal, function(temp){temp$ETSaccuracy}),
rw = sapply(train_test, accuracy_rw, function_name=accuracyFun),
rwd = sapply(train_test, accuracy_rwd, function_name=accuracyFun),
wn = sapply(train_test, accuracy_wn, function_name=accuracyFun),
theta = sapply(train_test, accuracy_theta, function_name=accuracyFun),
stlar = sapply(train_test, accuracy_stlar, function_name=accuracyFun),
nn = sapply(train_test, accuracy_nn, function_name=accuracyFun),
snaive = sapply(train_test, accuracy_snaive, function_name=accuracyFun),
mstl = sapply(train_test, accuracy_mstl, function_name=accuracyFun),
tbats = sapply(train_test, accuracy_tbats, function_name=accuracyFun)
)
})
#' forecast seasonally adjusted data, while the seasonal naive method is used to forecast
#' the seasonal component
#' @param y a univariate time series
#' @param h forecast horizon
#' @param s.window Either the character string “periodic” or the span (in lags) of the loess window for seasonal extraction
#' @param robust logical indicating if robust fitting be used in the loess procedue
#' @return return object of class forecast
#' @author Thiyanga Talagala
#' @import forecast
#' @export
stlar <- function(y, h=10, s.window=11, robust=FALSE)
{
if(!is.ts(y))
y <- ts(y, frequency=findfrequency(y))
if(frequency(y)==1 | length(y) <= 2*frequency(y))
return(forecast(auto.arima(y, max.q=0), h=h))
fit_stlm <- stlm(y,s.window=s.window, robust=robust, modelfunction=ar)
fcast <- forecast(fit_stlm, h=h)
return(fcast)
}
mat <- sapply(models, function(f){
switch(f,
arima = sapply(arima_cal, function(temp){temp$ARIMAaccuracy}),
ets = sapply(ets_cal, function(temp){temp$ETSaccuracy}),
rw = sapply(train_test, accuracy_rw, function_name=accuracyFun),
rwd = sapply(train_test, accuracy_rwd, function_name=accuracyFun),
wn = sapply(train_test, accuracy_wn, function_name=accuracyFun),
theta = sapply(train_test, accuracy_theta, function_name=accuracyFun),
stlar = sapply(train_test, accuracy_stlar, function_name=accuracyFun),
nn = sapply(train_test, accuracy_nn, function_name=accuracyFun),
snaive = sapply(train_test, accuracy_snaive, function_name=accuracyFun),
mstl = sapply(train_test, accuracy_mstl, function_name=accuracyFun),
tbats = sapply(train_test, accuracy_tbats, function_name=accuracyFun)
)
})
return(list(accuracy=mat, ARIMA = arima_models, ETS =ets_models))
list(accuracy=mat, ARIMA = arima_models, ETS =ets_models)
#'@param forecast forecast obtained from a fitted to the training period
#'@return returns a single value: mean on MASE and sMAPE
#'@author Thiyanga Talagala
#'@export
#'@examples
#'require(Mcomp)
#'require(magrittr)
#'ts <- M3[[1]]$x
#'fcast_arima <- auto.arima(ts) %>% forecast(h=6)
#'cal_avg(M3[[1]]$x, M3[[1]]$xx, fcast_arima$mean)
cal_avg <- function(training, test, forecast){
method_MASE <- cal_MASE(training, test, forecast)
method_sMAPE <- cal_sMAPE(training, test, forecast)
avg <- c(method_MASE, method_sMAPE)
return(avg)
}
require(Mcomp)
require(magrittr)
ts <- M3[[1]]$x
fcast_arima <- auto.arima(ts) %>% forecast(h=6)
cal_avg(M3[[1]]$x, M3[[1]]$xx, fcast_arima$mean)
sapply(train_test, accuracy_rw, function_name=accuracyFun)
library(seer)
sapply(train_test, accuracy_rw, function_name=accuracyFun)
mat <- sapply(models, function(f){
switch(f,
arima = sapply(arima_cal, function(temp){temp$ARIMAaccuracy}),
ets = sapply(ets_cal, function(temp){temp$ETSaccuracy}),
rw = sapply(train_test, accuracy_rw, function_name=accuracyFun),
rwd = sapply(train_test, accuracy_rwd, function_name=accuracyFun),
wn = sapply(train_test, accuracy_wn, function_name=accuracyFun),
theta = sapply(train_test, accuracy_theta, function_name=accuracyFun),
stlar = sapply(train_test, accuracy_stlar, function_name=accuracyFun),
nn = sapply(train_test, accuracy_nn, function_name=accuracyFun),
snaive = sapply(train_test, accuracy_snaive, function_name=accuracyFun),
mstl = sapply(train_test, accuracy_mstl, function_name=accuracyFun),
tbats = sapply(train_test, accuracy_tbats, function_name=accuracyFun)
)
})
matrix(data, nrow = rows, ncol = cols)
mat
arima_models <- NA
ets_models <- NA
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
if ("arima"%in% models) {
arima_cal <- lapply(train_test, accuracy_arima, function_name=accuracyFun)
arima_models <- sapply(arima_cal, function(temp){temp$ARIMAmodel})
}
if ("ets"%in% models) {
ets_cal <- lapply(train_test, accuracy_ets, function_name=accuracyFun)
ets_models <- sapply(ets_cal, function(temp){temp$ETSmodel})
}
mat <- sapply(models, function(f){
switch(f,
arima = sapply(arima_cal, function(temp){temp$ARIMAaccuracy}),
ets = sapply(ets_cal, function(temp){temp$ETSaccuracy}),
rw = sapply(train_test, accuracy_rw, function_name=accuracyFun),
rwd = sapply(train_test, accuracy_rwd, function_name=accuracyFun),
wn = sapply(train_test, accuracy_wn, function_name=accuracyFun),
theta = sapply(train_test, accuracy_theta, function_name=accuracyFun),
stlar = sapply(train_test, accuracy_stlar, function_name=accuracyFun),
nn = sapply(train_test, accuracy_nn, function_name=accuracyFun),
snaive = sapply(train_test, accuracy_snaive, function_name=accuracyFun),
mstl = sapply(train_test, accuracy_mstl, function_name=accuracyFun),
tbats = sapply(train_test, accuracy_tbats, function_name=accuracyFun)
)
})
list(accuracy=mat, ARIMA = arima_models, ETS =ets_models)
accuracyFun <- cal_MASE
arima_models <- NA
ets_models <- NA
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
if ("arima"%in% models) {
arima_cal <- lapply(train_test, accuracy_arima, function_name=accuracyFun)
arima_models <- sapply(arima_cal, function(temp){temp$ARIMAmodel})
}
if ("ets"%in% models) {
ets_cal <- lapply(train_test, accuracy_ets, function_name=accuracyFun)
ets_models <- sapply(ets_cal, function(temp){temp$ETSmodel})
}
mat <- sapply(models, function(f){
switch(f,
arima = sapply(arima_cal, function(temp){temp$ARIMAaccuracy}),
ets = sapply(ets_cal, function(temp){temp$ETSaccuracy}),
rw = sapply(train_test, accuracy_rw, function_name=accuracyFun),
rwd = sapply(train_test, accuracy_rwd, function_name=accuracyFun),
wn = sapply(train_test, accuracy_wn, function_name=accuracyFun),
theta = sapply(train_test, accuracy_theta, function_name=accuracyFun),
stlar = sapply(train_test, accuracy_stlar, function_name=accuracyFun),
nn = sapply(train_test, accuracy_nn, function_name=accuracyFun),
snaive = sapply(train_test, accuracy_snaive, function_name=accuracyFun),
mstl = sapply(train_test, accuracy_mstl, function_name=accuracyFun),
tbats = sapply(train_test, accuracy_tbats, function_name=accuracyFun)
)
})
list(accuracy=mat, ARIMA = arima_models, ETS =ets_models)
cal_measures
cal_avg
#'@param forecast forecast obtained from a fitted to the training period
#'@return returns a single value: mean on MASE and sMAPE
#'@author Thiyanga Talagala
#'@export
#'@examples
#'require(Mcomp)
#'require(magrittr)
#'ts <- M3[[1]]$x
#'fcast_arima <- auto.arima(ts) %>% forecast(h=6)
#'cal_m4measures(M3[[1]]$x, M3[[1]]$xx, fcast_arima$mean)
cal_m4measures <- function(training, test, forecast){
method_MASE <- cal_MASE(training, test, forecast)
method_sMAPE <- cal_sMAPE(training, test, forecast)
measures <- c(MASE=method_MASE, sMAPE=method_sMAPE)
return(measures)
}
require(Mcomp)
require(magrittr)
ts <- M3[[1]]$x
fcast_arima <- auto.arima(ts) %>% forecast(h=6)
cal_m4measures(M3[[1]]$x, M3[[1]]$xx, fcast_arima$mean)
accuracyFun <- cal_m4measures
arima_models <- NA
ets_models <- NA
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
if ("arima"%in% models) {
arima_cal <- lapply(train_test, accuracy_arima, function_name=accuracyFun)
arima_models <- sapply(arima_cal, function(temp){temp$ARIMAmodel})
}
if ("ets"%in% models) {
ets_cal <- lapply(train_test, accuracy_ets, function_name=accuracyFun)
ets_models <- sapply(ets_cal, function(temp){temp$ETSmodel})
}
mat <- sapply(models, function(f){
switch(f,
arima = sapply(arima_cal, function(temp){temp$ARIMAaccuracy}),
ets = sapply(ets_cal, function(temp){temp$ETSaccuracy}),
rw = sapply(train_test, accuracy_rw, function_name=accuracyFun),
rwd = sapply(train_test, accuracy_rwd, function_name=accuracyFun),
wn = sapply(train_test, accuracy_wn, function_name=accuracyFun),
theta = sapply(train_test, accuracy_theta, function_name=accuracyFun),
stlar = sapply(train_test, accuracy_stlar, function_name=accuracyFun),
nn = sapply(train_test, accuracy_nn, function_name=accuracyFun),
snaive = sapply(train_test, accuracy_snaive, function_name=accuracyFun),
mstl = sapply(train_test, accuracy_mstl, function_name=accuracyFun),
tbats = sapply(train_test, accuracy_tbats, function_name=accuracyFun)
)
})
list(accuracy=mat, ARIMA = arima_models, ETS =ets_models)
library(seer)
