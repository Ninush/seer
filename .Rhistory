snaive = sapply(train_test, SNAIVE, ACCURACY=accuracyFun),
mstl = sapply(train_test, MSTL, ACCURACY=accuracyFun),
tbats = sapply(train_test, TBATS, ACCURACY=accuracyFun)
)
})
return(list(accuracy=mat, ARIMA = arima_models, ETS =ets_models))
}
library(Mcomp)
m3_monthly <- subset(M3, "Monthly")
m3_monthly[[1]]
Arima(m3_monthly[[1]]$x, order=c(0,0,0))
a1 <- Arima(m3_monthly[[1]]$x, order=c(0,0,0))
forecast(A1, 12)
forecast(a1, 12)
mean(m3_monthly[[1]]$x)
rep(7, 2)
forecast(a1, 12)$mean
?auto.arima
training
WN <- function(ts_info, ACCURACY){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
fit_WN <- auto.arima(training, d=0, D=0, max.p=0, max.q = 0,
max.Q=0, max.P = 0)
forecastWN <- forecast(fit_WN,h)$mean
WNaccuracy <- ACCURACY(forecast=forecastWN,test=test, training=training)
return(WNaccuracy)
}
library(seer)
RWD <- function(ts_info, ACCURACY){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
if (sd(training)==0){return(NA)}
rwd_fit <- rwf(training,drift=TRUE, h=h)
forecastRWD <- forecast(rwd_fit)$mean
RWDaccuracy <- ACCURACY(forecast=forecastRWD, test=test, training=training)
return(RWDaccuracy)
}
a1 <- rep(10,10)
library(seer)
RWD(a1, cal_WA)
tsinfo <- list(training=rep(10, 10), test=rep(10,10))
RWD(tsinfo, cal_WA)
library(seer)
library(seer)
library(seer)
0/0.000000001
library(seer)
?denominator
#'Mean Absolute Scaled Error(MASE)
#'
#'Calculation of mean absolute scaled error
#'@param training training peiod of the time series
#'@param test test period of the time series
#'@param forecast forecast values of the series
#'@return returns a single value
#'@author Thiyanga Talagala
#'@export
cal_MASE <- function(training, test, forecast){
m <- frequency(training)
denominator <- mean(abs(diff(training, lag=m)))
if (denominator==0){qt_denominator=0.00000001
} else {
qt_denominator = denominator
}
q_t <- abs(test-forecast)/qt_denominator
return(mean(q_t))
}
require(Mcomp)
ts <- M3[[1]]$x
fcast_arima <- auto.arima(ts) %>% forecast(h=6)
cal_MASE(M3[[1]]$x, M3[[1]]$xx, fcast_arima$mean)
install.packages("uroot")
install.packages("uroot")
library(uroot)
library(seer)
library(Mcomp)
data(M3)
fit1 <- auto.arima(M3[[1]]$x)
fcast1 <- forecast(fit1, h=6)
accuracy(test=M3[[1]]$x, fit1)
accuracy(fcast1, test=M3[[1]]$x)
accuracy(fcast1, test=M3[[1]]$xx)
accuracy(fcast1, M3[[1]]$xx)
cal_MASE(M3[[1]]$x, M3[[1]]$xx, fcast1$mean)
#'Mean Absolute Scaled Error(MASE)
#'
#'Calculation of mean absolute scaled error
#'@param training training peiod of the time series
#'@param test test period of the time series
#'@param forecast forecast values of the series
#'@return returns a single value
#'@author Thiyanga Talagala
#'@export
cal_MASE <- function(training, test, forecast){
m <- frequency(training)
q_t <- abs(test-forecast)/mean(abs(diff(training, lag=m)))
return(mean(q_t))
}
cal_MASE(M3[[1]]$x, M3[[1]]$xx, fcast1$mean)
library(seer)
#' @param tslist a list of univariate time series
#' @param seasonal if FALSE, restricts to features suitable for non-seasonal data
#' @param m frequency of the time series
#' @param lagmax maximum lag at which to calculate the acf (quarterly series-5L and monthly-13L)
#' @param database whether the time series is from mcomp or other
#' @param h forecast horizon
#' @return dataframe: each column represent a feature and each row represent a time series
#' @importFrom magrittr %>%
#' @author Thiyanga Talagala
#' @export
cal_features <- function(tslist, seasonal=FALSE, m=1, lagmax=2L, database, h){ # tslist = yearly_m1,
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
train <- lapply(train_test, function(temp){temp$training})
ts_features_pkg <- tsfeatures::tsfeatures(train, c("entropy",
"lumpiness",
"stability",
"hurst",
"stl_features",
"acf_features",
"pacf_features",
"holt_parameters",
"nonlinearity"))
if (seasonal==FALSE){
ts_features1 <- ts_features_pkg %>% dplyr::select ("entropy", "lumpiness", "stability", "hurst",
"trend", "spike", "linearity", "curvature",
"e_acf1", "x_acf1", "diff1_acf1", "diff2_acf1",
"x_pacf5","diff1x_pacf5", "diff2x_pacf5", "alpha",
"beta","nonlinearity")
seer_features_nonseasonal <- lapply(train, function(temp1){c(
e_acf1(temp1),
unitroot(temp1))})
seer_features_nonseasonal_DF <- as.data.frame(do.call("rbind", seer_features_nonseasonal))
ts_features <- dplyr::bind_cols(ts_features1, seer_features_nonseasonal_DF)
} else {
ts_features1 <- ts_features_pkg %>% dplyr::select ("entropy", "lumpiness", "stability", "hurst",
"trend", "spike", "linearity", "curvature",
"e_acf1", "x_acf1", "diff1_acf1", "diff2_acf1",
"x_pacf5","diff1x_pacf5", "diff2x_pacf5", "alpha",
"beta","nonlinearity", "seasonal_strength",
"seas_pacf")
seer_features_seasonal <- lapply(train, function(temp1){c(holtWinter_parameters(temp1),
acf_seasonalDiff(temp1, m, lagmax))})
seer_features_seasonal_DF <- as.data.frame(do.call("rbind", seer_features_seasonal))
ts_features <- dplyr::bind_cols(ts_features1, seer_features_seasonal_DF)
}
ts_featuresDF <- as.data.frame(ts_features)
ts_featuresDF <- dplyr::rename(ts_featuresDF, "spikiness" = "spike")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "y_acf1" = "x_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff1y_acf1" = "diff1_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff2y_acf1" = "diff2_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "y_pacf5" = "x_pacf5")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff1y_pacf5" = "diff1x_pacf5")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff2y_pacf5" = "diff2x_pacf5")
if(seasonal==TRUE){
ts_featuresDF <- dplyr::rename(ts_featuresDF, "seasonality" = "seasonal_strength")
}
length <- lapply(train, function(temp){length(temp$x)})
length <- unlist(length)
ts_featuresDF$N <- length
seer_features <- lapply(train, function(temp1){acf5(temp1)})
seer_feature_DF <- as.data.frame(do.call("rbind", seer_features))
featureDF <- dplyr::bind_cols(ts_featuresDF,seer_feature_DF)
return(featureDF)
}
library(Mcomp)
M3_yearly <- subset(M3, "Yearly")
M3_yealy_sub <- M3_yealy[1:2]
M3_yealy_sub <- M3_yearly[1:2]
M3_yealy_sub
M3_yealy_sub[[1]]$x
M3_yealy_sub[[2]]$x
#' @param tslist a list of univariate time series
#' @param seasonal if FALSE, restricts to features suitable for non-seasonal data
#' @param m frequency of the time series
#' @param lagmax maximum lag at which to calculate the acf (quarterly series-5L and monthly-13L)
#' @param database whether the time series is from mcomp or other
#' @param h forecast horizon
#' @return dataframe: each column represent a feature and each row represent a time series
#' @importFrom magrittr %>%
#' @author Thiyanga Talagala
#' @export
cal_features <- function(tslist, seasonal=FALSE, m=1, lagmax=2L, database, h){ # tslist = yearly_m1,
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
train <- lapply(train_test, function(temp){temp$training})
ts_features_pkg <- tsfeatures::tsfeatures(train, c("entropy",
"lumpiness",
"stability",
"hurst",
"stl_features",
"acf_features",
"pacf_features",
"holt_parameters",
"nonlinearity"))
if (seasonal==FALSE){
ts_features1 <- ts_features_pkg %>% dplyr::select ("entropy", "lumpiness", "stability", "hurst",
"trend", "spike", "linearity", "curvature",
"e_acf1", "x_acf1", "diff1_acf1", "diff2_acf1",
"x_pacf5","diff1x_pacf5", "diff2x_pacf5", "alpha",
"beta","nonlinearity")
seer_features_nonseasonal <- lapply(train, function(temp1){c(
e_acf1(temp1),
unitroot(temp1))})
seer_features_nonseasonal_DF <- as.data.frame(do.call("rbind", seer_features_nonseasonal))
ts_features <- dplyr::bind_cols(ts_features1, seer_features_nonseasonal_DF)
} else {
ts_features1 <- ts_features_pkg %>% dplyr::select ("entropy", "lumpiness", "stability", "hurst",
"trend", "spike", "linearity", "curvature",
"e_acf1", "x_acf1", "diff1_acf1", "diff2_acf1",
"x_pacf5","diff1x_pacf5", "diff2x_pacf5", "alpha",
"beta","nonlinearity", "seasonal_strength",
"seas_pacf")
seer_features_seasonal <- lapply(train, function(temp1){c(holtWinter_parameters(temp1),
acf_seasonalDiff(temp1, m, lagmax))})
seer_features_seasonal_DF <- as.data.frame(do.call("rbind", seer_features_seasonal))
ts_features <- dplyr::bind_cols(ts_features1, seer_features_seasonal_DF)
}
ts_featuresDF <- as.data.frame(ts_features)
ts_featuresDF <- dplyr::rename(ts_featuresDF, "spikiness" = "spike")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "y_acf1" = "x_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff1y_acf1" = "diff1_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff2y_acf1" = "diff2_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "y_pacf5" = "x_pacf5")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff1y_pacf5" = "diff1x_pacf5")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff2y_pacf5" = "diff2x_pacf5")
if(seasonal==TRUE){
ts_featuresDF <- dplyr::rename(ts_featuresDF, "seasonality" = "seasonal_strength")
}
length <- lapply(train, function(temp){length(temp$x)})
length <- unlist(length)
ts_featuresDF$N <- length
seer_features <- lapply(train, function(temp1){acf5(temp1)})
seer_feature_DF <- as.data.frame(do.call("rbind", seer_features))
featureDF <- dplyr::bind_cols(ts_featuresDF,seer_feature_DF)
return(featureDF)
}
cal_features(M3_yealy_sub, database="M3", h=6)
library(ForeCA)
library(tsfeatures)
cal_features(M3_yealy_sub, database="M3", h=6)
traceback()
#' @param tslist a list of univariate time series
#' @param seasonal if FALSE, restricts to features suitable for non-seasonal data
#' @param m frequency of the time series
#' @param lagmax maximum lag at which to calculate the acf (quarterly series-5L and monthly-13L)
#' @param database whether the time series is from mcomp or other
#' @param h forecast horizon
#' @return dataframe: each column represent a feature and each row represent a time series
#' @importFrom magrittr %>%
#' @author Thiyanga Talagala
#' @export
cal_features <- function(tslist, seasonal=FALSE, m=1, lagmax=2L, database, h){ # tslist = yearly_m1,
if (database == "other") {
train_test <- lapply(tslist, function(temp){list(training=head_ts(temp,h), test=tail_ts(temp, h))})
} else {
train_test <- lapply(tslist, function(temp){list(training=temp$x, test=temp$xx)})
}
train <- lapply(train_test, function(temp){temp$training})
ts_features_pkg <- tsfeatures::tsfeatures(train, c("entropy",
"lumpiness",
"stability",
"hurst",
"stl_features",
"acf_features",
"pacf_features",
"holt_parameters",
"nonlinearity"))
if (seasonal==FALSE){
ts_features1 <- ts_features_pkg %>% dplyr::select ("entropy", "lumpiness", "stability", "hurst",
"trend", "spike", "linearity", "curvature",
"e_acf1", "x_acf1", "diff1_acf1", "diff2_acf1",
"x_pacf5","diff1x_pacf5", "diff2x_pacf5", "alpha",
"beta","nonlinearity")
seer_features_nonseasonal <- lapply(train, function(temp1){c(
e_acf1(temp1),
unitroot(temp1))})
seer_features_nonseasonal_DF <- as.data.frame(do.call("rbind", seer_features_nonseasonal))
ts_features <- dplyr::bind_cols(ts_features1, seer_features_nonseasonal_DF)
} else {
ts_features1 <- ts_features_pkg %>% dplyr::select ("entropy", "lumpiness", "stability", "hurst",
"trend", "spike", "linearity", "curvature",
"e_acf1", "x_acf1", "diff1_acf1", "diff2_acf1",
"x_pacf5","diff1x_pacf5", "diff2x_pacf5", "alpha",
"beta","nonlinearity", "seasonal_strength",
"seas_pacf")
seer_features_seasonal <- lapply(train, function(temp1){c(holtWinter_parameters(temp1),
acf_seasonalDiff(temp1, m, lagmax))})
seer_features_seasonal_DF <- as.data.frame(do.call("rbind", seer_features_seasonal))
ts_features <- dplyr::bind_cols(ts_features1, seer_features_seasonal_DF)
}
ts_featuresDF <- as.data.frame(ts_features)
ts_featuresDF <- dplyr::rename(ts_featuresDF, "spikiness" = "spike")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "y_acf1" = "x_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff1y_acf1" = "diff1_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff2y_acf1" = "diff2_acf1")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "y_pacf5" = "x_pacf5")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff1y_pacf5" = "diff1x_pacf5")
ts_featuresDF <- dplyr::rename(ts_featuresDF, "diff2y_pacf5" = "diff2x_pacf5")
if(seasonal==TRUE){
ts_featuresDF <- dplyr::rename(ts_featuresDF, "seasonality" = "seasonal_strength")
}
length <- lapply(train, function(temp){length(temp)})
length <- unlist(length)
ts_featuresDF$N <- length
seer_features <- lapply(train, function(temp1){acf5(temp1)})
seer_feature_DF <- as.data.frame(do.call("rbind", seer_features))
featureDF <- dplyr::bind_cols(ts_featuresDF,seer_feature_DF)
return(featureDF)
}
cal_features(M3_yealy_sub, database="M3", h=6)
myts <- list(rnorm(15), rnorm(12))
myts
myts[[1]]
myts[[2]]
myts <- list(ts(rnorm(15)), ts(rnorm(12)))
myts
cal_features(myts, database="other", h=6)
diff(rnorm(12))
diff(rnorm(6))
library(seer)
install.packages("hexSticker")
# sticker
library(hexSticker)
autoplot(M4[[1]]$x)
# plot
library(forecast)
library(seer)
autoplot(M4[[1]]$x)
# plot
library(ggplot2)
library(forecast)
library(seer)
autoplot(M4[[1]]$x)
data(M4)
autoplot(M4[[1]]$x)
?autoplot
autoplot(M4[[1]]$x, M4[[2]]$x)
autoplot(M4[[1]]$x)
autoplot(M4[[1]]$x)+geom_line(M4[[2]]$x)
#' Compute an accuracy measure from theta method
#' @param ts_info list containing training and test part of a time series
#' @param ACCURACY function to calculate the accuracy function, the arguments of this function
#' should be foecast, training and test set of the time series
#' @return a numeric value
#' @importFrom forecTheta stheta
#' @author Thiyanga Talagala
#' @export
THETA <- function(ts_info, ACCURACY){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
m <- frequency(training)
if (m > 1){
# using stheta method with seasonal adjustment
# require(forecTheta)
forecastTheta <- forecTheta::stheta(training,h=h, s='additive')$mean
THETAaccuracy <- ACCUARACY(forecast=forecastTheta, test=test, training=training)
} else {
# using thetaf method
forecastTheta <-forecast::thetaf(training,h=length(test))$mean
THETAaccuracy <- ACCURACY(forecast=forecastTheta, test=test, training=training)
}
return(THETAaccuracy)
}
THETA(list(training=rep(10,11), test=rep(11,5)), cal_sMAPE)
library(seer)
THETA(list(training=rep(10,11), test=rep(11,5)), cal_sMAPE)
THETA(list(training=rep(10,11), test=rep(10,5)), cal_sMAPE)
THETA(list(training=rep(10,11), test=rep(10,5)), cal_MASE)
training <- rep(10, 10)
m <- frequency(training)
m
test <- ep(5, 6)
test <- rep(5, 6)
# using thetaf method
forecastTheta <-forecast::thetaf(training,h=length(test))$mean
?nnetar
?mstl
?tabts
?tbats
#' Calculate accuracy measure from different forecasting methods
#'
#' Compute an accuracy measure from ETS models
#' @param ts_info list containing training and test part of a time series
#' @param ACCURACY function to calculate the accuracy function, the arguments of this function
#' should be forecast, training and test set of the time series
#' @return a list which contains the accuracy and name of the specific ETS model
#' @author Thiyanga Talagala
#' @export
ETS <- function(ts_info, function_name){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
ets_fit <- forecast::ets(training)
forecastETS <- forecast(ets_fit,h)$mean
ACCURACY <- match.fun(function_name)
ETSaccuracy <- ACCURACY(forecast=forecastETS,test=test, training=training)
ETSmodel <- as.character(ets_fit)
return(list(ETSmodel=ETSmodel, ETSaccuracy=ETSaccuracy))
}
library(Mcomp)
tslist <- list(training=M3[[1]]$x,)
tslist <- list(training=M3[[1]]$x, test = M3[[1]]$xx)
ETS(tslist, cal_sMAPE())
ETS(tslist, cal_sMAPE)
?match.fun
cc <- function(forecast, training, test){}
cc <- function(forecast, training, test){ return(mean(training))}
ETS(tslist, cc)
match.fun
?match.fun
?mstl
library(seer)
library(seer)
library(seer)
?accuracy_ets
?accuracy_arima
?accuracy_arima
library(seer)
?accuracy_arima
library(seer)
#' @rdname accuracy_ets
accuracy_rwd <- function(ts_info, function_name){
training <- ts_info$training
test <- ts_info$test
h <- length(test)
if (forecast::is.constant(training)==TRUE){return(NA)}
tryCatch({
rwd_fit <- rwf(training,drift=TRUE, h=h)
}, error=function(e){return(NA)})
forecastRWD <- forecast(rwd_fit)$mean
ACCURACY <- match.fun(function_name)
RWDaccuracy <- ACCURACY(forecast=forecastRWD, test=test, training=training)
return(RWDaccuracy)
}
alist <- list(training=rep(10, 15), test=rep(5, 6))
library(seer)
accuracy_rwd(alist, cal_avg)
library(seer)
alist <- list(training=M3[[1]]$x, test=M3[[1]]$xx)
accuracy_rwd(alist, cal_avg)
library(forecast)
accuracy_rwd(alist, cal_avg)
x=0.00
x=0.001
x==0
Inf+1
Inf>1
Inf<1
which.min(Inf, 3)
which.min(c(Inf, 3))
min(c(Inf, 3))
#'Mean Absolute Scaled Error(MASE)
#'
#'Calculation of mean absolute scaled error
#'@param training training peiod of the time series
#'@param test test period of the time series
#'@param forecast forecast values of the series
#'@return returns a single value
#'@author Thiyanga Talagala
#'@export
cal_MASE <- function(training, test, forecast){
m <- frequency(training)
q_t <- abs(test-forecast)/mean(abs(diff(training, lag=m)))
return(mean(q_t))
}
library(seer)
ts <- M3[[1]]$x
fcast_arima <- auto.arima(ts) %>% forecast(h=6)
require(Mcomp)
require(magrittr)
ts <- M3[[1]]$x
cal_MASE
fcast_arima <- auto.arima(ts) %>% forecast(h=6)
cal_MASE(M3[[1]]$x, M3[[1]]$xx, fcast_arima$mean)
accuracy(test=M3[[1]]$xx, auto.arima(ts))
fit <- auto.arima(ts)
?accuracy
accuracy(fit,test=M3[[1]]$xx)
fit1 <- rwf(EuStockMarkets[1:200,1],h=100)
fit2 <- meanf(EuStockMarkets[1:200,1],h=100)
accuracy(fit1)
accuracy(fcast_arima, M3[[1]]$xx)
cal_MASE(M3[[1]]$x, M3[[1]]$xx, fcast_arima$mean)
ts <- M3[[2]]$x
ts <- M3[[1000]]$x
plot(ts)
ts <- M3[[3000]]$x
plot(ts)
Qy <- subset(M3, "quarterly")
plot(Qy[[1]])
plot(Qy[[100]])
plot(Qy[[1001]])
plot(Qy[[500]])
ts <- Qy[[500]]
fcast_arima <- auto.arima(ts) %>% forecast(h=8)
ts <- Qy[[500]]$x
fcast_arima <- auto.arima(ts) %>% forecast(h=8)
cal_MASE(Qy[[500]]$x, Qy[[500]]$xx, fcast_arima$mean)
accuracy(fcast_arima, Qy[[500]]$xx)
Qy[[500]]
library(seer)
